<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>web on 知耻而后勇，知不足而后进</title>
    <link>https://feng1st.github.io/categories/web/index.xml</link>
    <description>Recent content in web on 知耻而后勇，知不足而后进</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>utf-8</language>
    <copyright>nf_xp</copyright>
    <atom:link href="https://feng1st.github.io/categories/web/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Tomcat笔记</title>
      <link>https://feng1st.github.io/post/2017-06-14-tomcat/</link>
      <pubDate>Wed, 14 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>https://feng1st.github.io/post/2017-06-14-tomcat/</guid>
      <description>

&lt;h2 id=&#34;架构&#34;&gt;架构&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Server: 整个容器&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Service: 关联Container和Connector的中间人，包含一个Container和多个Connector&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Connector: 负责和客户端的网络通讯，接受/建立连接，接收请求，返回响应&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;维持一个一定大小的线程池，创建多个Processor，当请求来的时候，将socket和processor绑定，然后运行&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Request, Response是在这里创建的，然后传递给Container&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;低版本Tomcat可以修改配置文件server.xml，为Connector使用&lt;code&gt;protocol=&amp;quot;org.apache.coyote.http11.Http11NioProtocol&amp;quot;&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Container: 所有容器的父接口，下面4个重要的实现类/子接口&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;Engine, Host, Context, Wrapper&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;4个之间不是并列关系，是父子包含关系&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Engine: 是一个Service的根容器，处理请求的总管道 Pipeline&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Host: Engine的子容器，负责处理访问某特定host的请求。还实现了Deployer接口，实现应用程序的展开、部署、启动&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Context: Host的子容器，负责处理访问某特定路径 path 的请求。也是我们的单个应用程序的单位&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Wrapper: Context的子容器，负责调用Filter和Servlet&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;LifeCycle: 生命周期管理，包括父容器启动时，分别启动子容器。父容器结束前，分别结束子容器&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Pipeline: Valve的容器，请求传递的责任链。Pipeline内的Valve依次调用，最后一个Valve调用下一层级的Pipeline&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;EngineValve1 -&amp;gt; EngineValve2 -&amp;gt; ... -&amp;gt; StandardEngineValve -&amp;gt; HostPipeline&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Valve: Pipeline的切入点&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;StandardEngineValve: Engine pipeline上最后一个valve，调用Host&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;StandardHostValve: Host pipeline上最后一个valve，调用Context&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;StandardContextValve: Context pipeline上最后一个valve，调用Wrapper&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;StandardWrapperValve: Wrapper pipeline上最后一个valve，负责生成并调用filterChain，最后调用servlet&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;处理请求&#34;&gt;处理请求&lt;/h2&gt;

&lt;p&gt;时序图见&lt;a href=&#34;http://tomcat.apache.org/tomcat-9.0-doc/architecture/requestProcess/request-process.png&#34;&gt;这里&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;classloader&#34;&gt;ClassLoader&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;是典型的双亲委托模式 Parents Delegation Model&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;要求：&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;common目录下的类被Tomcat和应用使用&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;server目录下的类只被Tomcat使用&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;shared目录下的类可以被所有应用使用&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;应用目录下的类只可以被本应用使用&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;实现（ClassLoader层级关系）：&lt;br /&gt;
&lt;div class=&#34;mermaid&#34;&gt;
graph RL
    commonLoader--&gt;systemLoader
    catalinaLoader--&gt;commonLoader
    sharedLoader--&gt;commonLoader
    webAppLoader1--&gt;sharedLoader
    webAppLoader2--&gt;sharedLoader
    
&lt;/div&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Jetty笔记</title>
      <link>https://feng1st.github.io/post/2017-06-12-jetty/</link>
      <pubDate>Mon, 12 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>https://feng1st.github.io/post/2017-06-12-jetty/</guid>
      <description>

&lt;h2 id=&#34;核心组成部分&#34;&gt;核心组成部分&lt;/h2&gt;

&lt;div class=&#34;mermaid&#34;&gt;
graph LR
L(LifeCycle)
C(Connector)---S(Server)
H(Handler)---S
S---P(ThreadPool)

&lt;/div&gt;


&lt;h2 id=&#34;lifecycle&#34;&gt;LifeCycle&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;start();
stop();
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;管理server对象的生命周期&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Connector, Handler, ThreadPool都实现了LifeCycle接口&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;LifeCycle的监听使用了观察者模式&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;connector&#34;&gt;Connector&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;接受TCP连接&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;用配置的ConnectionFactory创建Connection，和连接绑定&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;可配置多个ConnectionFactory，链式调用，分别完成各自一层的工作，比如：&lt;br /&gt;

&lt;ol&gt;
&lt;li&gt;ProxyConnectionFactory：处理Proxy协议&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;SslConnectionFactory：SSL加密解密&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;HttpConnectionFactory：处理实际的HTTP请求&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;handler&#34;&gt;Handler&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;http://www.eclipse.org/jetty/documentation/current/images/basic-architecture-handlers.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Jetty用一个Handler模型就完成了请求在整个server的不同层级的处理，这个是Jetty保持轻量和容易扩展的原因，这里说一下它的设计模式。&lt;br /&gt;

&lt;ol&gt;
&lt;li&gt;HandlerWrapper：形式上是装饰者模式，使用方式上是责任链模式&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;装饰者模式 Decorator：实现对所包装对象在本层级的拦截。比如，SessionHandler处理Session，SecurityHandler处理安全验证后，再调用被包装Handler的handle()&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;责任链模式 Chain of Responsibility：已经提到过，调用被包装Handler的handle()，实现责任链&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;HandlerContainer：组合模式 Composite，树形结构&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;模板方法 Template Method：比如ScopedHandler.doScope()，更清晰的向使用者阐述类的职责&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;门面模式 Facade：Context相关类，限制暴露方法的范围&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;Handler风格分类：&lt;br /&gt;

&lt;ol&gt;
&lt;li&gt;协调型，路由请求到其它Handler（HandlerCollection, ContextHandlerCollection）&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;过滤型，拦截修改到其它Handler的请求（HandlerWrapper, SessionHandler, ContextHandler）&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;处理型，处理请求，生成响应（StaticHandler, ServletHandler）&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;调用方式：&lt;br /&gt;
&lt;img src=&#34;http://www.eclipse.org/jetty/documentation/current/images/basic-architecture-nested-handlers.png&#34; alt=&#34;&#34; /&gt;&lt;br /&gt;

&lt;ol&gt;
&lt;li&gt;顺序调用，代表：HandlerCollection&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;嵌套调用，代表：HandlerWrapper&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;servlethandler&#34;&gt;ServletHandler&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;http://www.eclipse.org/jetty/documentation/current/images/basic-architecture-servlet-handler.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;ServletHandler持有多个FilterHolder和ServletHolder&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;作为Servlet容器，调用时先调用所有的Filter，再调用Servlet&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;context&#34;&gt;Context&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;简单的说，分组环境变量&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;几个时序图&#34;&gt;几个时序图&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Jetty启动&lt;br /&gt;
&lt;img src=&#34;https://www.ibm.com/developerworks/cn/java/j-lo-jetty/image011.jpg&#34; alt=&#34;&#34; /&gt;&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;先启动线程池，再启动Handler，最后Connector。前者是处理后者的前提。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Jetty建立连接&lt;br /&gt;
&lt;img src=&#34;https://www.ibm.com/developerworks/cn/java/j-lo-jetty/image013.jpg&#34; alt=&#34;&#34; /&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Jetty处理连接&lt;br /&gt;
&lt;img src=&#34;https://www.ibm.com/developerworks/cn/java/j-lo-jetty/image015.jpg&#34; alt=&#34;&#34; /&gt;&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;注意Request/Response是在什么地方创建的&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;引用来源&#34;&gt;引用来源&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://www.eclipse.org/jetty/documentation/current/architecture.html&#34;&gt;http://www.eclipse.org/jetty/documentation/current/architecture.html&lt;/a&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.ibm.com/developerworks/cn/java/j-lo-jetty/&#34;&gt;https://www.ibm.com/developerworks/cn/java/j-lo-jetty/&lt;/a&gt;&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Servlet笔记</title>
      <link>https://feng1st.github.io/post/2017-06-11-servlet/</link>
      <pubDate>Sun, 11 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>https://feng1st.github.io/post/2017-06-11-servlet/</guid>
      <description>

&lt;p&gt;教程：&lt;br /&gt;
&lt;a href=&#34;http://tutorials.jenkov.com/java-servlets/&#34;&gt;http://tutorials.jenkov.com/java-servlets/&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;一些思考点&#34;&gt;一些思考点&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Servlet的生命周期是怎样被&lt;strong&gt;容器&lt;/strong&gt;管理的？&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Session是怎样被管理和传递的？&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;分布式环境下Session是怎样被管理的？&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;ServletContext是怎样被管理和传递的，典型用途是什么？&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;为什么要使用RequestDispatcher，而不是，比如直接调用其它Servlet？&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Filter和Servlet有什么异同？&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Filter和Servlet分属不同两个类，为什么filterChain.doFilter()能把请求传递给Servlet&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;怎样用Filter实现GZip，这个实现和AOP有什么区别？&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Session和ServletContext是线程安全的吗？&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
  </channel>
</rss>