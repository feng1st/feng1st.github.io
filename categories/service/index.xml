<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>service on 知耻而后勇，知不足而后进</title>
    <link>https://feng1st.github.io/categories/service/index.xml</link>
    <description>Recent content in service on 知耻而后勇，知不足而后进</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>utf-8</language>
    <copyright>nf_xp</copyright>
    <atom:link href="https://feng1st.github.io/categories/service/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>微服务架构笔记</title>
      <link>https://feng1st.github.io/post/2017-06-19-microservices/</link>
      <pubDate>Mon, 19 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>https://feng1st.github.io/post/2017-06-19-microservices/</guid>
      <description>

&lt;p&gt;原文：&lt;a href=&#34;http://blog.csdn.net/mindfloating/article/details/24583369&#34;&gt;http://blog.csdn.net/mindfloating/article/details/24583369&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;什么是微服务架构&#34;&gt;什么是微服务架构&lt;/h2&gt;

&lt;p&gt;采用一组服务的方式来构建一个应用；&lt;br /&gt;
服务独立部署在不同的进程；&lt;br /&gt;
服务之间通过轻量级的机制来通讯，比如RPC、HTTP；&lt;br /&gt;
服务可独立扩展伸缩；&lt;br /&gt;
每个服务定义了明确的边界；&lt;br /&gt;
不同服务可以采用不同的技术实现，由独立的团队维护。&lt;/p&gt;

&lt;h2 id=&#34;微服务架构的特征&#34;&gt;微服务架构的特征&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;通过服务实现组件化&lt;br /&gt;
和传统方式，或者说单一架构(Monolithic Architecture)类比：&lt;br /&gt;
传统方式实现组件化：通过库(library)；和应用运行在一个进程里；组件升级，应用需要重新部署&lt;br /&gt;
服务方式实现组件化：通过服务；部署在不同的进程；可以单独升级&lt;br /&gt;
因为服务是跨进程的，所以在设计阶段就必须定义好明确的边界&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;按业务能力来划分服务和组织团队&lt;br /&gt;
传统方式按技术分层：前端、后端、数据库&lt;br /&gt;
微服务架构：按业务划分，全栈工程师或全栈团队&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;服务即产品&lt;br /&gt;
团队即负责开发，也负责维护&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;智能终端和哑管道&lt;br /&gt;
抛弃过于复杂的ESB，服务自己处理自己的业务逻辑&lt;br /&gt;
服务间通讯尽量轻量，不添加额外的规则&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;去中心统一化&lt;br /&gt;
各服务可以选用自己的技术实现&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;自动化基础设施服务&lt;br /&gt;
必须要存在自动化的服务治理平台，才能降低开发、调试、测试、部署、监控、维护的复杂度&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Design for failure&lt;br /&gt;
服务消费者要优雅的处理远程调用带来的错误&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;进化设计&lt;br /&gt;
发送方要最小化，只发送必要的信息&lt;br /&gt;
接收方要最大化，要最大化容错，要允许传入不认识的参数&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;服务的划分&#34;&gt;服务的划分&lt;/h2&gt;

&lt;p&gt;参考点之一：如果功能A发生改变，功能B也要随之改变，一般它们应划在同一个服务里&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>面向服务架构笔记</title>
      <link>https://feng1st.github.io/post/2017-06-18-soa/</link>
      <pubDate>Sun, 18 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>https://feng1st.github.io/post/2017-06-18-soa/</guid>
      <description>

&lt;h2 id=&#34;分布式应用架构的演化&#34;&gt;分布式应用架构的演化&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;DOA 分布式对象架构&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;主要特征：&lt;br /&gt;

&lt;ol&gt;
&lt;li&gt;对象是可以在服务器/容器间自由“移动”的&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;被调用的对象究竟是本地，还是远程，对调用者来说是透明的&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;例子：EJB&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;问题：复杂和性能&lt;br /&gt;

&lt;ol&gt;
&lt;li&gt;远程调用有更多可能出错的环节&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;分布式事务需要两阶段提交&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;远程通讯额外的开销&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;SOA 面向服务架构&lt;br /&gt;

&lt;ol&gt;
&lt;li&gt;服务是可“移动”的，但是远没有DOA那样不可控&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;当调用其它服务时，调用者知道这是一个远程调用。对复杂度和性能有更好的把控&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;企业服务总线-esb&#34;&gt;企业服务总线 ESB&lt;/h2&gt;

&lt;p&gt;ESB是SOA的核心组件，其主要特点：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;服务访问单点：服务提供者和服务消费者都只需要知道ESB的存在。服务发生变化，只需要修改ESB的配置&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;事物管理器：分布式事物管理器放在这个地方很自然&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;安全管理器：访问权限、授权管理&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;服务代理：统一服务接口和数据格式的一个Adaptor和Proxy&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;对外部的网关&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;但是ESB也有一定的缺点：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;单点故障：ESB发生故障，整个系统将不可用&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;单点性能：分布式系统中，承担ESB角色的单点是必须的，比如服务注册和发现。&lt;br /&gt;
但是，究竟要承担哪些具体的工作，是一个需要考虑的点。&lt;br /&gt;
比如，如果服务之间的通讯都要经过ESB，ESB会不会成为整个系统的性能瓶颈，会不会增大故障的概率&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;同上，增加了服务间访问的间接性，降低了性能&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;soa简介&#34;&gt;SOA简介&lt;/h2&gt;

&lt;p&gt;SOA的目标是实现灵活可变的分布式IT系统，这需要：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;标准化：协议标准化，实现互访问&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;复用：服务可复用&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;松耦合可编排：分布式对象技术分离了连接逻辑，消息中间件实现了连接逻辑的异步，SOA架构实现了业务逻辑的解耦&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;soa治理&#34;&gt;SOA治理&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;服务注册与发现&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;可靠性&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;安全性&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;负载均衡&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;监控与日志&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;服务限流和容错&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;完整soa模型&#34;&gt;完整SOA模型&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;基础设施服务&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;企业服务总线&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;关键服务组件&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;开发工具&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;管理工具&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;参考资料&#34;&gt;参考资料&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://tutorials.jenkov.com/soa/&#34;&gt;http://tutorials.jenkov.com/soa/&lt;/a&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.vsharing.com/fengjicheng/A1059842.html&#34;&gt;http://blog.vsharing.com/fengjicheng/A1059842.html&lt;/a&gt;&lt;br /&gt;
-&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>高并发解决思路</title>
      <link>https://feng1st.github.io/post/2017-06-17-high-concurrency/</link>
      <pubDate>Sat, 17 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>https://feng1st.github.io/post/2017-06-17-high-concurrency/</guid>
      <description>

&lt;p&gt;解决高并发，无非两个方向：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;分而治之：分流&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;优化单个服务器处理能力&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;客户端&#34;&gt;客户端&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;尽量使用缓存&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;尽量本地处理&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;尽量减少不必要的访问&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;分流&#34;&gt;分流&lt;/h2&gt;

&lt;p&gt;LVS、Nginx、Varnish放到一块说&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;负载均衡&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;业务拆分&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;静态内容直接返回，包括使用CDN&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;缓存（动态内容缓存、页面片段缓存）&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;优化单个服务器处理程序&#34;&gt;优化单个服务器处理程序&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;缓存：缓存永远是最重要的&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;异步：能异步就异步&lt;br /&gt;
如果有多个异步调用没有依赖关系，可以并行调用，然后在最后一起等结果&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;多线程：&lt;br /&gt;
如果是CPU吃重的应用，线程数过高不能解决问题&lt;br /&gt;
I/O吃重要分成两种：1种是因为传输数据量过大，导致I/O重，这种线程数高不解决问题&lt;br /&gt;
另一种是传输数据不大，但是等待远端处理的时间很长，这种可以提升线程数，并发处理后面的任务&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;预处理：预先算出局部结果，要获取整体结果时，只需要基于局部结果计算。比如月报表可以基于天报表&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;还有一种预处理，是和缓存结合的预处理&lt;br /&gt;
不是等到缓存失效时，再穿透后端。而是缓存快要失效时，就起线程向后端请求数据更新缓存。在线程处理期间，缓存里的数据依然是有效的。线程处理完毕，缓存里的数据已更新&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;优化SQL，正确使用索引&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;尽量不要使用分布式事务&lt;br /&gt;
2阶段提交不是万能药&lt;br /&gt;

&lt;ol&gt;
&lt;li&gt;各节点进入事务&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;各节点事务执行完毕，prepare（意味着，接下来出了问题，比如重启，事务也能生效）&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;各节点commit&lt;br /&gt;
假设最后一个节点，commit前离线了，并且永远不再上线，事务状态依然是错误的&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;应用算法优化&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;优化数据层&#34;&gt;优化数据层&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;合理选用数据库（OLTP、OLAP）和引擎（InnoDB、MyISAM）&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;合理设置索引&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;使用集群，读写分离&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;合理分表分库&lt;br /&gt;
分表我看来最大的好处是，是索引变小，能够加载到内存&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
  </channel>
</rss>