<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>servlet-container on 知耻而后勇，知不足而后进</title>
    <link>https://feng1st.github.io/tags/servlet-container/index.xml</link>
    <description>Recent content in servlet-container on 知耻而后勇，知不足而后进</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>utf-8</language>
    <copyright>nf_xp</copyright>
    <atom:link href="https://feng1st.github.io/tags/servlet-container/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Jetty简介</title>
      <link>https://feng1st.github.io/post/2017-06-12-jetty/</link>
      <pubDate>Mon, 12 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>https://feng1st.github.io/post/2017-06-12-jetty/</guid>
      <description>

&lt;h2 id=&#34;核心组成部分&#34;&gt;核心组成部分&lt;/h2&gt;

&lt;div class=&#34;mermaid&#34;&gt;
graph LR
L(LifeCycle)
C(Connector)---S(Server)
H(Handler)---S
S---P(ThreadPool)

&lt;/div&gt;


&lt;h2 id=&#34;lifecycle&#34;&gt;LifeCycle&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;start();
stop();
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;管理server对象的生命周期&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Connector, Handler, ThreadPool都实现了LifeCycle接口&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;LifeCycle的监听使用了观察者模式&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;connector&#34;&gt;Connector&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;接受TCP连接&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;用配置的ConnectionFactory创建Connection，和连接绑定&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;可配置多个ConnectionFactory，链式调用，分别完成各自一层的工作，比如：&lt;br /&gt;

&lt;ol&gt;
&lt;li&gt;ProxyConnectionFactory：处理Proxy协议&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;SslConnectionFactory：SSL加密解密&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;HttpConnectionFactory：处理实际的HTTP请求&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;handler&#34;&gt;Handler&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;http://www.eclipse.org/jetty/documentation/current/images/basic-architecture-handlers.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Jetty用一个Handler模型就完成了请求在整个server的不同层级的处理，这个是Jetty保持轻量和容易扩展的原因，这里说一下它的设计模式。&lt;br /&gt;

&lt;ol&gt;
&lt;li&gt;HandlerWrapper：形式上是装饰者模式，使用方式上是责任链模式&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;装饰者模式 Decorator：实现对所包装对象在本层级的拦截。比如，SessionHandler处理Session，SecurityHandler处理安全验证后，再调用被包装Handler的handle()&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;责任链模式 Chain of Responsibility：已经提到过，调用被包装Handler的handle()，实现责任链&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;HandlerContainer：组合模式 Composite，树形结构&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;模板方法 Template Method：比如ScopedHandler.doScope()，更清晰的向使用者阐述类的职责&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;门面模式 Facade：Context相关类，限制暴露方法的范围&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;Handler风格分类：&lt;br /&gt;

&lt;ol&gt;
&lt;li&gt;协调型，路由请求到其它Handler（HandlerCollection, ContextHandlerCollection）&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;过滤型，拦截修改到其它Handler的请求（HandlerWrapper, SessionHandler, ContextHandler）&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;处理型，处理请求，生成响应（StaticHandler, ServletHandler）&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;调用方式：&lt;br /&gt;
&lt;img src=&#34;http://www.eclipse.org/jetty/documentation/current/images/basic-architecture-nested-handlers.png&#34; alt=&#34;&#34; /&gt;&lt;br /&gt;

&lt;ol&gt;
&lt;li&gt;顺序调用，代表：HandlerCollection&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;嵌套调用，代表：HandlerWrapper&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;servlethandler&#34;&gt;ServletHandler&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;http://www.eclipse.org/jetty/documentation/current/images/basic-architecture-servlet-handler.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;ServletHandler持有多个FilterHolder和ServletHolder&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;作为Servlet容器，调用时先调用所有的Filter，再调用Servlet&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;context&#34;&gt;Context&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;简单的说，分组环境变量&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;几个时序图&#34;&gt;几个时序图&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Jetty启动&lt;br /&gt;
&lt;img src=&#34;https://www.ibm.com/developerworks/cn/java/j-lo-jetty/image011.jpg&#34; alt=&#34;&#34; /&gt;&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;先启动线程池，再启动Handler，最后Connector。前者是处理后者的前提。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Jetty建立连接&lt;br /&gt;
&lt;img src=&#34;https://www.ibm.com/developerworks/cn/java/j-lo-jetty/image013.jpg&#34; alt=&#34;&#34; /&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Jetty处理连接&lt;br /&gt;
&lt;img src=&#34;https://www.ibm.com/developerworks/cn/java/j-lo-jetty/image015.jpg&#34; alt=&#34;&#34; /&gt;&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;注意Request/Response是在什么地方创建的&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;引用来源&#34;&gt;引用来源&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://www.eclipse.org/jetty/documentation/current/architecture.html&#34;&gt;http://www.eclipse.org/jetty/documentation/current/architecture.html&lt;/a&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.ibm.com/developerworks/cn/java/j-lo-jetty/&#34;&gt;https://www.ibm.com/developerworks/cn/java/j-lo-jetty/&lt;/a&gt;&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
  </channel>
</rss>