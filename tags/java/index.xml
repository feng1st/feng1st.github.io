<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>java on 知耻而后勇，知不足而后进</title>
    <link>https://feng1st.github.io/tags/java/index.xml</link>
    <description>Recent content in java on 知耻而后勇，知不足而后进</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>utf-8</language>
    <copyright>nf_xp</copyright>
    <atom:link href="https://feng1st.github.io/tags/java/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Tomcat笔记</title>
      <link>https://feng1st.github.io/post/2017-06-14-tomcat/</link>
      <pubDate>Wed, 14 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>https://feng1st.github.io/post/2017-06-14-tomcat/</guid>
      <description>

&lt;h2 id=&#34;架构&#34;&gt;架构&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Server: 整个容器&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Service: 关联Container和Connector的中间人，包含一个Container和多个Connector&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Connector: 负责和客户端的网络通讯，接受/建立连接，接收请求，返回响应&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;维持一个一定大小的线程池，创建多个Processor，当请求来的时候，将socket和processor绑定，然后运行&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Request, Response是在这里创建的，然后传递给Container&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;低版本Tomcat可以修改配置文件server.xml，为Connector使用&lt;code&gt;protocol=&amp;quot;org.apache.coyote.http11.Http11NioProtocol&amp;quot;&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Container: 所有容器的父接口，下面4个重要的实现类/子接口&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;Engine, Host, Context, Wrapper&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;4个之间不是并列关系，是父子包含关系&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Engine: 是一个Service的根容器，处理请求的总管道 Pipeline&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Host: Engine的子容器，负责处理访问某特定host的请求。还实现了Deployer接口，实现应用程序的展开、部署、启动&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Context: Host的子容器，负责处理访问某特定路径 path 的请求。也是我们的单个应用程序的单位&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Wrapper: Context的子容器，负责调用Filter和Servlet&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;LifeCycle: 生命周期管理，包括父容器启动时，分别启动子容器。父容器结束前，分别结束子容器&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Pipeline: Valve的容器，请求传递的责任链。Pipeline内的Valve依次调用，最后一个Valve调用下一层级的Pipeline&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;EngineValve1 -&amp;gt; EngineValve2 -&amp;gt; ... -&amp;gt; StandardEngineValve -&amp;gt; HostPipeline&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Valve: Pipeline的切入点&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;StandardEngineValve: Engine pipeline上最后一个valve，调用Host&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;StandardHostValve: Host pipeline上最后一个valve，调用Context&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;StandardContextValve: Context pipeline上最后一个valve，调用Wrapper&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;StandardWrapperValve: Wrapper pipeline上最后一个valve，负责生成并调用filterChain，最后调用servlet&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;处理请求&#34;&gt;处理请求&lt;/h2&gt;

&lt;p&gt;时序图&lt;br /&gt;

&lt;figure &gt;
    &lt;a href=&#34;request-process.png&#34;&gt;
        &lt;img src=&#34;request-process.png&#34; /&gt;
    &lt;/a&gt;
    
&lt;/figure&gt;
&lt;/p&gt;

&lt;h2 id=&#34;classloader&#34;&gt;ClassLoader&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;是典型的双亲委托模式 Parents Delegation Model&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;要求：&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;common目录下的类被Tomcat和应用使用&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;server目录下的类只被Tomcat使用&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;shared目录下的类可以被所有应用使用&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;应用目录下的类只可以被本应用使用&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;实现（ClassLoader层级关系）：&lt;br /&gt;
&lt;div class=&#34;mermaid&#34;&gt;
graph RL
    commonLoader--&gt;systemLoader
    catalinaLoader--&gt;commonLoader
    sharedLoader--&gt;commonLoader
    webAppLoader1--&gt;sharedLoader
    webAppLoader2--&gt;sharedLoader
    
&lt;/div&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Jetty笔记</title>
      <link>https://feng1st.github.io/post/2017-06-12-jetty/</link>
      <pubDate>Mon, 12 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>https://feng1st.github.io/post/2017-06-12-jetty/</guid>
      <description>

&lt;h2 id=&#34;核心组成部分&#34;&gt;核心组成部分&lt;/h2&gt;

&lt;div class=&#34;mermaid&#34;&gt;
graph LR
L(LifeCycle)
C(Connector)---S(Server)
H(Handler)---S
S---P(ThreadPool)

&lt;/div&gt;


&lt;h2 id=&#34;lifecycle&#34;&gt;LifeCycle&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;start();
stop();
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;管理server对象的生命周期&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Connector, Handler, ThreadPool都实现了LifeCycle接口&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;LifeCycle的监听使用了观察者模式&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;connector&#34;&gt;Connector&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;接受TCP连接&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;用配置的ConnectionFactory创建Connection，和连接绑定&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;可配置多个ConnectionFactory，链式调用，分别完成各自一层的工作，比如：&lt;br /&gt;

&lt;ol&gt;
&lt;li&gt;ProxyConnectionFactory：处理Proxy协议&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;SslConnectionFactory：SSL加密解密&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;HttpConnectionFactory：处理实际的HTTP请求&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;handler&#34;&gt;Handler&lt;/h2&gt;


&lt;figure &gt;
    &lt;a href=&#34;basic-architecture-handlers.png&#34;&gt;
        &lt;img src=&#34;basic-architecture-handlers.png&#34; /&gt;
    &lt;/a&gt;
    
&lt;/figure&gt;


&lt;ol&gt;
&lt;li&gt;Jetty用一个Handler模型就完成了请求在整个server的不同层级的处理，这个是Jetty保持轻量和容易扩展的原因，这里说一下它的设计模式。&lt;br /&gt;

&lt;ol&gt;
&lt;li&gt;HandlerWrapper：形式上是装饰者模式，使用方式上是责任链模式&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;装饰者模式 Decorator：实现对所包装对象在本层级的拦截。比如，SessionHandler处理Session，SecurityHandler处理安全验证后，再调用被包装Handler的handle()&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;责任链模式 Chain of Responsibility：已经提到过，调用被包装Handler的handle()，实现责任链&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;HandlerContainer：组合模式 Composite，树形结构&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;模板方法 Template Method：比如ScopedHandler.doScope()，更清晰的向使用者阐述类的职责&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;门面模式 Facade：Context相关类，限制暴露方法的范围&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;Handler风格分类：&lt;br /&gt;

&lt;ol&gt;
&lt;li&gt;协调型，路由请求到其它Handler（HandlerCollection, ContextHandlerCollection）&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;过滤型，拦截修改到其它Handler的请求（HandlerWrapper, SessionHandler, ContextHandler）&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;处理型，处理请求，生成响应（StaticHandler, ServletHandler）&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;调用方式：&lt;br /&gt;

&lt;figure &gt;
    &lt;a href=&#34;basic-architecture-nested-handlers.png&#34;&gt;
        &lt;img src=&#34;basic-architecture-nested-handlers.png&#34; /&gt;
    &lt;/a&gt;
    
&lt;/figure&gt;
&lt;br /&gt;

&lt;ol&gt;
&lt;li&gt;顺序调用，代表：HandlerCollection&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;嵌套调用，代表：HandlerWrapper&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;servlethandler&#34;&gt;ServletHandler&lt;/h2&gt;


&lt;figure &gt;
    &lt;a href=&#34;basic-architecture-servlet-handler.png&#34;&gt;
        &lt;img src=&#34;basic-architecture-servlet-handler.png&#34; /&gt;
    &lt;/a&gt;
    
&lt;/figure&gt;


&lt;ol&gt;
&lt;li&gt;ServletHandler持有多个FilterHolder和ServletHolder&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;作为Servlet容器，调用时先调用所有的Filter，再调用Servlet&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;context&#34;&gt;Context&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;简单的说，分组环境变量&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;几个时序图&#34;&gt;几个时序图&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Jetty启动&lt;br /&gt;

&lt;figure &gt;
    &lt;a href=&#34;image011.jpg&#34;&gt;
        &lt;img src=&#34;image011.jpg&#34; /&gt;
    &lt;/a&gt;
    
&lt;/figure&gt;
&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;先启动线程池，再启动Handler，最后Connector。前者是处理后者的前提。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Jetty建立连接&lt;br /&gt;

&lt;figure &gt;
    &lt;a href=&#34;image013.jpg&#34;&gt;
        &lt;img src=&#34;image013.jpg&#34; /&gt;
    &lt;/a&gt;
    
&lt;/figure&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Jetty处理连接&lt;br /&gt;

&lt;figure &gt;
    &lt;a href=&#34;image015.jpg&#34;&gt;
        &lt;img src=&#34;image015.jpg&#34; /&gt;
    &lt;/a&gt;
    
&lt;/figure&gt;
&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;注意Request/Response是在什么地方创建的&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;引用来源&#34;&gt;引用来源&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://www.eclipse.org/jetty/documentation/current/architecture.html&#34;&gt;http://www.eclipse.org/jetty/documentation/current/architecture.html&lt;/a&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.ibm.com/developerworks/cn/java/j-lo-jetty/&#34;&gt;https://www.ibm.com/developerworks/cn/java/j-lo-jetty/&lt;/a&gt;&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Servlet笔记</title>
      <link>https://feng1st.github.io/post/2017-06-11-servlet/</link>
      <pubDate>Sun, 11 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>https://feng1st.github.io/post/2017-06-11-servlet/</guid>
      <description>

&lt;p&gt;教程：&lt;br /&gt;
&lt;a href=&#34;http://tutorials.jenkov.com/java-servlets/&#34;&gt;http://tutorials.jenkov.com/java-servlets/&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;一些思考点&#34;&gt;一些思考点&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Servlet的生命周期是怎样被&lt;strong&gt;容器&lt;/strong&gt;管理的？&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Session是怎样被管理和传递的？&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;分布式环境下Session是怎样被管理的？&lt;br /&gt;

&lt;ol&gt;
&lt;li&gt;统一Session中心&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;或者Session Sticky&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;ServletContext是怎样被管理和传递的，典型用途是什么？&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;request.getSession().getServletContext();&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;为什么要使用RequestDispatcher，而不是，比如直接调用其它Servlet？&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Filter和Servlet有什么异同？&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;接口&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;Servlet: init(), service(), destroy()&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;HttpServlet: doGet(), doPost(), &amp;hellip;&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Filter: init(), doFilter(), destroy()&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;设计&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;Servlet: 面向事务&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Filter: 面向切面&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Filter和Servlet分属不同两个类，为什么filterChain.doFilter()能把请求传递给Servlet&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;filterChain最后一个默认的filter调用servlet&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;怎样用Filter实现GZip，这个实现和AOP有什么区别？&lt;br /&gt;

&lt;ol&gt;
&lt;li&gt;判断请求头Accept-Encoding是否包括gzip&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;增加响应头Content-Encoding&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;用带GZip的Response封装原Response，并向后传递&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;Session和ServletContext是线程安全的吗？&lt;br /&gt;
不安全&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Java NIO摘要</title>
      <link>https://feng1st.github.io/post/2017-06-10-java-nio/</link>
      <pubDate>Sat, 10 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>https://feng1st.github.io/post/2017-06-10-java-nio/</guid>
      <description>

&lt;p&gt;比较经典和精简的教程，先直接发链接：&lt;br /&gt;
&lt;a href=&#34;http://tutorials.jenkov.com/java-nio/&#34;&gt;http://tutorials.jenkov.com/java-nio/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;NIO的实现不复杂，但是其体现了一个统一、可伸缩的面向数据/信息流的设计思想&lt;br /&gt;
例如，换用消息队列，就可以扩展到分布式系统里去&lt;/p&gt;

&lt;h2 id=&#34;一些思考点&#34;&gt;一些思考点&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Channel和Stream有什么不同？&lt;br /&gt;

&lt;ol&gt;
&lt;li&gt;Channel双向，Stream一般单向&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Channel支持异步&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Channel搭配Buffer使用&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;ServerSocketChannel和SocketChannel有什么不同？&lt;br /&gt;

&lt;ol&gt;
&lt;li&gt;SocketChannel用于单个连接&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;ServerSocketChannel用于监听端口，对每一个接受的连接创建一个SocketChannel&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;FileChannel.transferTo(&amp;hellip;, SocketChannel)有什么需要注意的？&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;SocketChannel非阻塞且发送缓冲已满，可能只传输部分&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;SocketChannel的blocking和non-blocking模式有什么不同？&lt;br /&gt;

&lt;ol&gt;
&lt;li&gt;相对于阻塞，connect()直接返回，需要后继调用finishConnect()判断成功&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;write()/read()可能未实际读写就返回&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;ServerSocketChannel的blocking和non-blocking模式有什么不同？&lt;br /&gt;

&lt;ol&gt;
&lt;li&gt;相对于阻塞，accept()直接返回，如没有接受连接，返回null&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;write()/read()可能未实际读写就返回&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;Blocking模式Socket有什么问题？&lt;br /&gt;

&lt;ol&gt;
&lt;li&gt;一般会用一个线程处理一个连接，所以支撑的连接数非常有限&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;如果使用连接池复用活动连接，一些慢速或者非活动连接可能会占满连接池&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;Non-blocking模式Socket有哪些挑战？&lt;br /&gt;

&lt;ol&gt;
&lt;li&gt;读到的字节流拆分Message：文章提到了TLV，但最好用长度+内容+校验构成&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;长度：TLV中的L&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;内容：类型是包含在这里面的，比如protobuf协议&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;校验：用于验证数据错误，或者网络错误，通知重传&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;读写的Message要有长度限制，否则一个伪造的字节流就能把服务器撑垮&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;一般会定义一种特定Message，专门用来拆分大的其它Message，长度和校验部分机制不变，内容部分构成如下&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;总段数&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;本段序号&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;本段内容&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;发送方不能把所有的Channel都注册到Selector，因为Selector.select()时，可能大部分Channel都可写，全部返回，性能低下&lt;br /&gt;

&lt;ol&gt;
&lt;li&gt;当本Channel对应缓冲区有待发送数据时，才注册到Selector&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;当缓冲区数据发送完毕时，从Selector取消注册&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;Selector有哪两种底层实现？&lt;br /&gt;

&lt;ol&gt;
&lt;li&gt;Reactor：轮询Channel对应底层IO句柄。当连接数过多时，性能低下。这个可以算是多路复用，因为select()时还是有等待的过程&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;e-poll：注册回调函数，只有当有对应事件发生时，才通知Selector。这个算是真正的异步。Linux直接支持&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;阻塞/非阻塞，同步/异步&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;阻塞：调用io函数会一直等待，比如System.in.read()&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;非阻塞：调用io函数，只读写可以读写的部分，然后立刻返回，比如NIO&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;同步：用等待或者轮询的方式拿到结果，比如NIO&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;异步：当时不用拿到结果，事后再获取结果，或者等到结果通知。使用Future或者Callback，比如AsynchronousFileChannel&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;额外提一下Node.js的线程模型&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;
&lt;figure &gt;
    &lt;a href=&#34;733213-20160306210005159-1364173213.png&#34;&gt;
        &lt;img src=&#34;733213-20160306210005159-1364173213.png&#34; /&gt;
    &lt;/a&gt;
    
&lt;/figure&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Java内存模型和GC机制摘要</title>
      <link>https://feng1st.github.io/post/2017-06-07-jvm-memory-gc/</link>
      <pubDate>Wed, 07 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>https://feng1st.github.io/post/2017-06-07-jvm-memory-gc/</guid>
      <description>

&lt;h2 id=&#34;java对象&#34;&gt;Java对象&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;对象位置&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;对象实例在堆中分配&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;实例对应的类信息在方法区分配&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;对象信息&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;对象实例包含对象头和对象属性&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;对象头包含对象信息，包括分代年龄、锁信息等；还包括对方法区类信息的引用&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;类信息包含对父类/接口的引用，用于方法重载&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;对象大小&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;空对象大小等于对象头大小，在32位虚拟机占8字节，64位占16字节，开启压缩占12字节&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;引用在32位虚拟机占4字节，64位占8字节，开启压缩占4字节&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;数组类型大小要在元素类型大小上增加4字节数组长度&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;对象最终大小按8字节对齐&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;java内存区域&#34;&gt;Java内存区域&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;程序计数器 Program Counter Register&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;每线程&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;对于Java方法，记录当前字节码位置；对于Native方法，记录为Undefined&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;虚拟机栈 VM Stack&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;每线程&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;保存方法调用时的栈帧 Stack Frame&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;栈帧存放方法调用的局部变量表、操作栈、动态连接、方法出口等&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;局部变量表保存简单变量和对象的引用&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;栈帧大小在方法生存期内固定&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;如果栈深度超过虚拟机规定大小，抛出StackOverflowError&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;如果可供分配的内存不够，抛出OutOfMemoryError&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;本地方法栈 Native Method Stack&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;类似虚拟机栈&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;堆 Heap&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;线程共享&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;存储对象实例&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;是涉及GC的主要区域&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;方法区 Method Area&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;线程共享&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;保存加载的类信息（包括版本、接口、属性、方法、final常量、静态变量等）和运行时常量池 Runtime Constant Pool（包括字面常量、符号引用和直接引用）&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;在分代GC机制里，一般被成为永久代 Permanent Gen&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;对于存在大量Proxy动态类的系统，要考虑回收的问题&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;堆和栈的区别&#34;&gt;堆和栈的区别&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;栈：存放栈帧，内部包括简单变量和对象引用，在栈顶分配，后进先出，速度快&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;堆：存放对象实例，会因回收造成内存碎片，需要寻找下一个可供分配的连续空间，速度慢&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;对象访问方式&#34;&gt;对象访问方式&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;通过句柄池&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;栈或堆中的对象引用指向句柄池句柄，句柄分别指向堆中对象实例和方法区类信息&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;对象引用到句柄是多对一，句柄到对象实例是一对一，意味着对象实例因为GC移动而发生地址改变，只需要修改句柄&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;直接分配&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;栈或堆中的对象引用指向堆中的对象实例，对象实例内部指向方法区类信息&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;无中间层，较快。但是一旦对象实例移动，则需要更新所有的引用&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;HotSpot采用&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;对象生命周期&#34;&gt;对象生命周期&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;引用计数法&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;存在环状引用的问题&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;可达性分析算法&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;GC Roots&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;虚拟机栈引用的对象&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;本地方法栈引用的对象&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;方法区类静态属性引用的对象&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;方法区常量引用的对象&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;内存分代&#34;&gt;内存分代&lt;/h2&gt;

&lt;p&gt;不同对象的生存周期不同，不能因为回收短期对象，就扫描整个堆区&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;年轻代 Young Gen&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;默认分配区域&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;老年代 Old Gen&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;存放多次回收后依然幸存的对象，或者无法在年轻代分配的大对象&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;永久代 Permanent Gen&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;存放方法区内容，HotSpot采用，但计划弃用&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;回收算法&#34;&gt;回收算法&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;复制算法 Copying&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;A、B两块空间，在A块连续分配，空间不够时，将A块的存活对象依次复制到B块头部，并切换使用B块，A块清空&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;分配简单，连续分配，快；需要两倍空间，浪费；复制内容如果过大，依然会慢&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;标记-清除算法 Mark-Sweep&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;先对所有可回收对象做标记，然后再回收这些对象所占的空间&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;不需要移动，快；回收后会有内存碎片&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;标记-整理算法 Mark-Compact&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;先对所有可回收对象做标记，然后将幸存对象依次前移&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;需要移动，慢；回收后无内存碎片&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;分配机制&#34;&gt;分配机制&lt;/h2&gt;

&lt;p&gt;HotSpot中，年轻代分为1个Eden和2个Survivor。在Eden区分配对象，如果空间不足，将Eden区和活动Survivor区幸存对象，根据幸存次数，分别移至备用Survivor和老年代中，然后切换活动/备用Survivor。&lt;/p&gt;

&lt;h2 id=&#34;回收方式&#34;&gt;回收方式&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;串行 Serial&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;暂停用户线程，单线程回收&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;并行 Parallel&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;暂停用户线程，多线程并行回收&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;并发 Concurrent&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;回收线程和用户线程同时工作&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;垃圾回收器&#34;&gt;垃圾回收器&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Serial收集器&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;新生代&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;停止复制算法（停止 Stop-the-World，在垃圾回收时，暂停用户线程）&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;串行回收&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;ParNew收集器&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;新生代&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;停止复制算法&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;并行回收&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Parallel Scavenge收集器&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;新生代&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;停止复制算法&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;并行回收&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;关注吞吐量、支持自适应调节&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Serial Old收集器&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;老年代&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;停止标记整理算法&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;串行回收&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;CMS收集器Concurrent Mode Failure的后备&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Parallel Old收集器&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;老年代&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;停止标记整理算法&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;并行回收&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;搭配Parallel Scavenge收集器&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;CMS收集器&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;老年代&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;标记清除算法&lt;br /&gt;

&lt;ol&gt;
&lt;li&gt;初始标记：停止，串行，仅标记GC Roots直接引用的对象&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;并发标记：并发，从初始标记对象往下追踪&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;重新标记：停止，并行，修正并发标记期间改变的对象&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;并发清除：并发&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;并发回收会占用运行时CPU资源&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;因为是并发回收，所以要为GC期间新生成的对象预留空间，如果空间不够，会抛出Concurrent Mode Failure，回退到Serial Old收集器&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;因为是标记清除算法，如果产生的内存碎片导致可用连续空间不足，会触发一次带整理的Full GC&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;G1收集器&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;堆划分为相同的区域 Region&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;优先回收价值最大的区域&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;使用Remembered Set避免全堆扫描&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;整体为标记整理算法，区域间为复制算法&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;初始标记：停止，串行&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;并发标记：并发&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;最终标记：停止，并行&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;筛选回收：停止，并行&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;gc监控&#34;&gt;GC监控&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;jstat可以用来实时查看内存分配及GC信息&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;jmap可以dump出内存对象，供进一步分析&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Java命令行参数可以设置输出详细GC日志，供进一步分析&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>