<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>microservices on Code One</title>
    <link>http://codeone.io/tags/microservices/</link>
    <description>Recent content in microservices on Code One</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Fri, 23 Jun 2017 00:00:00 +0000</lastBuildDate><atom:link href="http://codeone.io/tags/microservices/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>【笔记】微服务介绍</title>
      <link>http://codeone.io/notes/2017/2017-06-23-introduction-to-microservices/</link>
      <pubDate>Fri, 23 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>http://codeone.io/notes/2017/2017-06-23-introduction-to-microservices/</guid>
      <description>原文: https://www.nginx.com/blog/introduction-to-microservices/
单一框架有什么问题 / 微服务框架解决什么问题？ 单一框架经过常年发展，扩充之后：
 过于复杂，难于理解和修改。修改容易引入bug 启动变慢，降低调试和开发速度 无法持续部署，无法快速升级。一个组件需要升级，整个应用都需要重新部署。部署后，因为受影响部分不明，需要更多的人工测试 无法根据不同组件的需求进行伸缩扩展。比如，部分组件是CPU密集型，部分组件是内存密集型；部分组件压力小，单个实例可以应付，部分组件压力大，有部署多个实例的需求 可靠性，组件异常（比如内存泄露），导致整个应用异常 难于升级到新的技术和框架  微服务框架  按功能划分，比如订单管理、客户端管理 每个微服务是一个单独的小应用 微服务对外暴露API，比如REST API 微服务之间可以通过暴露的API互相调用 微服务间还可以通过消息系统实现异步调用 外界一般不直接范围后端服务，而是通过API网关 微服务通常通过虚拟机或Docker部署  伸缩模型 x轴：水平复制，靠克隆伸缩。通过在负载均衡后部署多个实例，解决可用性和吞吐量的问题 y轴：功能解耦，靠拆分不同的事物伸缩。将单一应用通过功能/业务拆分成多个微服务 z轴：数据分区，靠拆分相似的事物伸缩
微服务架构对数据库schema的影响 微服务架构要求每个微服务有自己单独的数据库schema 这是为了更彻底的解耦 但是不可避免的，多个微服务数据库间存在重复数据
微服务架构和SOA的异同 微服务架构和SOA在表现层有相似性：都是由多个服务构成 区别：
 微服务架构弃用了比较重的WS规范，采用轻量的协议，比如REST 微服务架构弃用了ESB  微服务的好处  将单一应用解构成多个服务，让每一个服务面临的复杂度降低，变得可管理、可控制、可维护 开发方面：可以选用自己的技术，可以使用较新的技术 部署方面：可以单独部署，更容易部署和测试 伸缩方面：更容易按需扩展多实例  微服务的问题 下面这些问题都不难解决，但是需要清楚存在这些问题
 分布式架构下调用的开销，以及服务不可用的处理 数据库拆分后，分布式事务基本不采用，需要最终一致方案 测试更困难，可能需要启动服务本身和依赖服务（或者伪服务） 升级链，如果A依赖于B，需要先升级B，再升级A 部署，需要自动化工具  API网关 门面模式 Facade
客户端直接和后端服务通讯的问题 / API网关要解决的问题  客户端需要调用多个后端服务，走广域网，非常慢 客户端代码复杂 客户端需要支持后端服务API所使用的通讯协议 后端服务接口无法自由变更，服务之间无法合并和拆分  API网关除了解决上诉问题，还能：
 提供负载均衡、缓存、安全/权限控制，监控等 为不同的客户端提供不同的接口  挑战：  需要额外实现和维护一个高可用的组件 可能成为开发瓶颈  实现API网关  性能和高伸缩性  要支持异步、非阻塞通讯 技术选型：Netty, Spring Reactor, &amp;hellip;   使用反应式编程模型 Reactive Programming Model  需求：要支持直接转发单个请求；要支持调用多个请求，并聚合结果 需求：要支持彼此无关服务的并发调用；要支持有依赖关系服务的先后调用 不推荐使用回调实现异步（不直观、不容易理解、容易出错） 推荐使用Reactive 技术选型：CompletableFuture, RxJava   服务调用  同步调用：HTTP、Thrift 异步、消息机制：JMS、AMQP、Zeromq API网关需要这些服务通讯，也应支持上诉通讯机制   服务发现  客户端发现：先请求服务地址列表，然后选择调用，负载均衡在客户端 服务端发现：注册总心选好后发给客户端，负载均衡在服务端 （这里的客户端指API网关）   处理部分失败  面对服务慢或者不可用的处理。核心是不能阻塞API网关 要根据服务是否重要，选择：  直接返回给客户端错误 返回空、默认值、缓存值、备份数据等   技术选型：Netflix Hystrix    进程间通讯 IPC 交互风格     一对一 一对多     同步 Request/Response &amp;ndash;   异步 Notification Publish/Subscribe    Request/Async response Public/Async responses     Request/Response: 发送请求，等待响应。应有超时。线程阻塞 Notification (单向请求): 发送请求，不期待有响应 Request/Async response: 发送请求，不期待有即时响应。线程不阻塞 Publish/Subscribe: 发布请求，多个消费者消费 Publish/Async responses: 发布请求，等待多个响应。有超时  接口设计  基于消息：定义消息channel和消息类型 基于HTTP：定义URL、请求和响应格式  接口升级  向前兼容的小升级，比如增加/删除请求/响应字段：  缺失的字段采用默认值，忽略额外的字段 消息格式要支持，比如Protobuf，Json   大的升级：要使用版本区分，服务要在一段时间内同时支持新旧版本接口  处理部分失败  一定要有超时，不能无限阻塞 要限制客户端向同一服务的请求的数量，如果超限，直接失败 船舱隔离模式：  不同的调用分配到不同的线程池，不能因为慢速调用占满快速调用的线程池   电路熔断器模式：  连续超时：断开 等待一段时间：半开放  又有超时：再断开 或不再超时：恢复     要根据服务是否重要，选择：  直接返回给客户端错误 返回空、默认值、缓存值、备份数据等    IPC技术 异步、基于消息的通讯 关键字：消息头、消息体、频道、生产者、消费者、broker、点对点、发布/订阅、…… 这里不展开</description>
    </item>
    
  </channel>
</rss>
