<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Web Server on 技术随笔</title>
    <link>http://codeone.io/tags/web-server/</link>
    <description>Recent content in Web Server on 技术随笔</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Wed, 14 Jun 2017 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="http://codeone.io/tags/web-server/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Tomcat笔记</title>
      <link>http://codeone.io/post/2017/06/tomcat/</link>
      <pubDate>Wed, 14 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>http://codeone.io/post/2017/06/tomcat/</guid>
      <description>架构  Server: 整个容器
 Service: 关联Container和Connector的中间人，包含一个Container和多个Connector
 Connector: 负责和客户端的网络通讯，接受/建立连接，接收请求，返回响应
 维持一个一定大小的线程池，创建多个Processor，当请求来的时候，将socket和processor绑定，然后运行
 Request, Response是在这里创建的，然后传递给Container
 低版本Tomcat可以修改配置文件server.xml，为Connector使用protocol=&amp;quot;org.apache.coyote.http11.Http11NioProtocol&amp;quot;
  Container: 所有容器的父接口，下面4个重要的实现类/子接口
 Engine, Host, Context, Wrapper
 4个之间不是并列关系，是父子包含关系
  Engine: 是一个Service的根容器，处理请求的总管道 Pipeline
 Host: Engine的子容器，负责处理访问某特定host的请求。还实现了Deployer接口，实现应用程序的展开、部署、启动
 Context: Host的子容器，负责处理访问某特定路径 path 的请求。也是我们的单个应用程序的单位
 Wrapper: Context的子容器，负责调用Filter和Servlet
 LifeCycle: 生命周期管理，包括父容器启动时，分别启动子容器。父容器结束前，分别结束子容器
 Pipeline: Valve的容器，请求传递的责任链。Pipeline内的Valve依次调用，最后一个Valve调用下一层级的Pipeline
 EngineValve1 -&amp;gt; EngineValve2 -&amp;gt; ... -&amp;gt; StandardEngineValve -&amp;gt; HostPipeline
  Valve: Pipeline的切入点
 StandardEngineValve: Engine pipeline上最后一个valve，调用Host
 StandardHostValve: Host pipeline上最后一个valve，调用Context</description>
    </item>
    
    <item>
      <title>Jetty笔记</title>
      <link>http://codeone.io/post/2017/06/jetty/</link>
      <pubDate>Mon, 12 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>http://codeone.io/post/2017/06/jetty/</guid>
      <description>核心组成部分  Server
 Connector
 Handler
 ThreadPool
 LifeCycle
  LifeCycle start(); stop();   管理server对象的生命周期
 Connector, Handler, ThreadPool都实现了LifeCycle接口
 LifeCycle的监听使用了观察者模式
  Connector  接受TCP连接
 用配置的ConnectionFactory创建Connection，和连接绑定
 可配置多个ConnectionFactory，链式调用，分别完成各自一层的工作，比如：
 ProxyConnectionFactory：处理Proxy协议
 SslConnectionFactory：SSL加密解密
 HttpConnectionFactory：处理实际的HTTP请求
   Handler  Jetty用一个Handler模型就完成了请求在整个server的不同层级的处理，这个是Jetty保持轻量和容易扩展的原因，这里说一下它的设计模式。
 HandlerWrapper：形式上是装饰者模式，使用方式上是责任链模式
 装饰者模式 Decorator：实现对所包装对象在本层级的拦截。比如，SessionHandler处理Session，SecurityHandler处理安全验证后，再调用被包装Handler的handle()
 责任链模式 Chain of Responsibility：已经提到过，调用被包装Handler的handle()，实现责任链
  HandlerContainer：组合模式 Composite，树形结构
 模板方法 Template Method：比如ScopedHandler.doScope()，更清晰的向使用者阐述类的职责
 门面模式 Facade：Context相关类，限制暴露方法的范围
  Handler风格分类：</description>
    </item>
    
  </channel>
</rss>