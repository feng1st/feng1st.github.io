<!DOCTYPE html>
<html lang="utf-8">

<head>
    <meta charset="utf-8">
    <meta name="generator" content="Hugo 0.18.1" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
    <meta name="description" content="知耻而后勇，知不足而后进">
    <meta name="author" content="">

    <link rel="stylesheet" href="/css/bootstrap-3.3.7.min.css">
    <link rel="stylesheet" href="/css/theme.css">
    <link rel="stylesheet" href="/css/site.css">
    <link rel="stylesheet" href="/css/highlight-github-9.10.0.min.css">

<link rel="stylesheet" type="text/css" href="https://cdn.rawgit.com/knsv/mermaid/6.0.0/dist/mermaid.css">


    <link rel="alternate" type="application/rss+xml" title="RSS" href="https://feng1st.github.io//index.xml">

    
    <title>微服务架构摘要 - 知耻而后勇，知不足而后进</title>
    <meta property='og:title' content="微服务架构摘要 - 知耻而后勇，知不足而后进">
    <meta property="og:type" content="article">
    

    <meta property="og:url" content="https://feng1st.github.io/post/2017-06-23-microservices/">
    
    
</head>

<body>


    <div class="container">

      
      <nav class="navbar navbar-default">
        <div class="container-fluid">
          <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
              <span class="sr-only">Toggle navigation</span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">知耻而后勇，知不足而后进</a>
          </div>
          
        </div>
      </nav>


<div class="row">
    <div class="col-lg-8">

        <article class="single well" itemscope="itemscope" itemtype="http://schema.org/Article">
            <meta itemprop="mainEntityOfPage"  itemType="https://schema.org/WebPage" content="https://feng1st.github.io/"/>
            <meta itemprop="dateModified" content="2017-06-23T00:00:00&#43;00:00">
            <meta itemprop="headline" content="微服务架构摘要">
            <meta itemprop="description" content="原文: https://www.nginx.com/blog/introduction-to-microservices/
单一框架有什么问题 / 微服务框架解决什么问题？ 单一框架经过常年发展，扩充之后：
 过于复杂，难于理解和修改。修改容易引入bug
 启动变慢，降低调试和开发速度
 无法持续部署，无法快速升级。一个组件需要升级，整个应用都需要重新部署。部署后，因为受影响部分不明，需要更多的人工测试
 无法根据不同组件的需求进行伸缩扩展。比如，部分组件是CPU密集型，部分组件是内存密集型；部分组件压力小，单个实例可以应付，部分组件压力大，有部署多个实例的需求
 可靠性，组件异常（比如内存泄露），导致整个应用异常
 难于升级到新的技术和框架
  微服务框架  按功能划分，比如订单管理、客户端管理
 每个微服务是一个单独的小应用
 微服务对外暴露API，比如REST API
微服务之间可以通过暴露的API互相调用
微服务间还可以通过消息系统实现异步调用
外界一般不直接范围后端服务，而是通过API网关
 微服务通常通过虚拟机或Docker部署
  伸缩模型 x轴：水平复制，靠克隆伸缩。通过在负载均衡后部署多个实例，解决可用性和吞吐量的问题
y轴：功能解耦，靠拆分不同的事物伸缩。将单一应用通过功能/业务拆分成多个微服务
z轴：数据分区，靠拆分相似的事物伸缩
微服务架构对数据库schema的影响 微服务架构要求每个微服务有自己单独的数据库schema
这是为了更彻底的解耦
但是不可避免的，多个微服务数据库间存在重复数据
微服务架构和SOA的异同 微服务架构和SOA在表现层有相似性：都是由多个服务构成
区别：
1. 微服务架构弃用了比较重的WS规范，采用轻量的协议，比如REST
2. 微服务架构弃用了ESB
微服务的好处  将单一应用解构成多个服务，让每一个服务面临的复杂度降低，变得可管理、可控制、可维护
 开发方面：可以选用自己的技术，可以使用较新的技术
 部署方面：可以单独部署，更容易部署和测试
 伸缩方面：更容易按需扩展多实例
  微服务的问题 下面这些问题都不难解决，但是需要清楚存在这些问题
 分布式架构下调用的开销，以及服务不可用的处理
 数据库拆分后，分布式事务基本不采用，需要最终一致方案
 测试更困难，可能需要启动服务本身和依赖服务（或者伪服务）">
            <meta itemprop="url" content="https://feng1st.github.io/post/2017-06-23-microservices/">
            <div itemprop="image" itemscope itemtype="https://schema.org/ImageObject">
                <meta itemprop="url" content="https://feng1st.github.io/images/default.jpg" />
                <meta itemprop="width" content="800">
                <meta itemprop="height" content="800">
            </div>
            <div itemprop="publisher" itemscope itemtype="https://schema.org/Organization">
                <div itemprop="logo" itemscope itemtype="https://schema.org/ImageObject">
                    <meta itemprop="url" content="https://feng1st.github.io/images/logo.jpg">
                    <meta itemprop="width" content="100">
                    <meta itemprop="height" content="100">
                </div>
                <meta itemprop="name" content="知耻而后勇，知不足而后进">
            </div>
            <div itemprop="author" itemscope itemtype="https://schema.org/Person">
                <meta itemprop="name" content="nf_xp">
            </div>
            <header class="article-header">
                <h1>微服务架构摘要</h1>
                
                <time itemprop="datePublished" pubdate="pubdate" datetime="2017-06-23T00:00:00&#43;00:00"><i class="fa fa-clock-o"></i> Posted on June 23, 2017</time>
                
                
                
                <div class="section">
                    <i class="fa fa-folder-o"></i> <a href="https://feng1st.github.io//categories/service" class="tag">Service</a>
                </div>
                
                
                <div class="section">
                    <i class="fa fa-tag"></i> <a href="https://feng1st.github.io//tags/microservices" class="tag">Microservices</a>
                </div>
                
            </header>

            
            

<p>原文: <a href="https://www.nginx.com/blog/introduction-to-microservices/">https://www.nginx.com/blog/introduction-to-microservices/</a></p>

<h2 id="单一框架有什么问题-微服务框架解决什么问题">单一框架有什么问题 / 微服务框架解决什么问题？</h2>

<p>单一框架经过常年发展，扩充之后：</p>

<ol>
<li>过于复杂，难于理解和修改。修改容易引入bug<br /></li>
<li>启动变慢，降低调试和开发速度<br /></li>
<li>无法持续部署，无法快速升级。一个组件需要升级，整个应用都需要重新部署。部署后，因为受影响部分不明，需要更多的人工测试<br /></li>
<li>无法根据不同组件的需求进行伸缩扩展。比如，部分组件是CPU密集型，部分组件是内存密集型；部分组件压力小，单个实例可以应付，部分组件压力大，有部署多个实例的需求<br /></li>
<li>可靠性，组件异常（比如内存泄露），导致整个应用异常<br /></li>
<li>难于升级到新的技术和框架<br />
<br /></li>
</ol>

<h2 id="微服务框架">微服务框架</h2>

<ol>
<li>按功能划分，比如订单管理、客户端管理<br /></li>
<li>每个微服务是一个单独的小应用<br /></li>
<li>微服务对外暴露API，比如REST API<br />
微服务之间可以通过暴露的API互相调用<br />
微服务间还可以通过消息系统实现异步调用<br />
外界一般不直接范围后端服务，而是通过API网关<br /></li>
<li>微服务通常通过虚拟机或Docker部署<br />
<br /></li>
</ol>

<h3 id="伸缩模型">伸缩模型</h3>

<p>x轴：水平复制，靠克隆伸缩。通过在负载均衡后部署多个实例，解决可用性和吞吐量的问题<br />
y轴：功能解耦，靠拆分不同的事物伸缩。将单一应用通过功能/业务拆分成多个微服务<br />
z轴：数据分区，靠拆分相似的事物伸缩</p>

<h3 id="微服务架构对数据库schema的影响">微服务架构对数据库schema的影响</h3>

<p>微服务架构要求每个微服务有自己单独的数据库schema<br />
这是为了更彻底的解耦<br />
但是不可避免的，多个微服务数据库间存在重复数据</p>

<h3 id="微服务架构和soa的异同">微服务架构和SOA的异同</h3>

<p>微服务架构和SOA在表现层有相似性：都是由多个服务构成<br />
区别：<br />
1. 微服务架构弃用了比较重的WS规范，采用轻量的协议，比如REST<br />
2. 微服务架构弃用了ESB</p>

<h3 id="微服务的好处">微服务的好处</h3>

<ol>
<li>将单一应用解构成多个服务，让每一个服务面临的复杂度降低，变得可管理、可控制、可维护<br /></li>
<li>开发方面：可以选用自己的技术，可以使用较新的技术<br /></li>
<li>部署方面：可以单独部署，更容易部署和测试<br /></li>
<li>伸缩方面：更容易按需扩展多实例<br />
<br /></li>
</ol>

<h3 id="微服务的问题">微服务的问题</h3>

<p>下面这些问题都不难解决，但是需要清楚存在这些问题</p>

<ol>
<li>分布式架构下调用的开销，以及服务不可用的处理<br /></li>
<li>数据库拆分后，分布式事务基本不采用，需要最终一致方案<br /></li>
<li>测试更困难，可能需要启动服务本身和依赖服务（或者伪服务）<br /></li>
<li>升级链，如果A依赖于B，需要先升级B，再升级A<br /></li>
<li>部署，需要自动化工具<br />
<br /></li>
</ol>

<h2 id="api网关">API网关</h2>

<p>门面模式 Facade</p>

<h3 id="客户端直接和后端服务通讯的问题-api网关要解决的问题">客户端直接和后端服务通讯的问题 / API网关要解决的问题</h3>

<ol>
<li>客户端需要调用多个后端服务，走广域网，非常慢<br /></li>
<li>客户端代码复杂<br /></li>
<li>客户端需要支持后端服务API所使用的通讯协议<br /></li>
<li>后端服务接口无法自由变更，服务之间无法合并和拆分<br />
<br /></li>
</ol>

<p>API网关除了解决上诉问题，还能：<br />
1. 提供负载均衡、缓存、安全/权限控制，监控等<br />
2. 为不同的客户端提供不同的接口</p>

<h3 id="挑战">挑战：</h3>

<ol>
<li>需要额外实现和维护一个高可用的组件<br /></li>
<li>可能成为开发瓶颈<br />
<br /></li>
</ol>

<h3 id="实现api网关">实现API网关</h3>

<ol>
<li>性能和高伸缩性<br />

<ul>
<li>要支持异步、非阻塞通讯<br /></li>
<li>技术选型：Netty, Spring Reactor, &hellip;<br /></li>
</ul></li>
<li>使用反应式编程模型 Reactive Programming Model<br />

<ul>
<li>需求：要支持直接转发单个请求；要支持调用多个请求，并聚合结果<br /></li>
<li>需求：要支持彼此无关服务的并发调用；要支持有依赖关系服务的先后调用<br /></li>
<li>不推荐使用回调实现异步（不直观、不容易理解、容易出错）<br /></li>
<li>推荐使用Reactive<br /></li>
<li>技术选型：CompletableFuture, RxJava<br /></li>
</ul></li>
<li>服务调用<br />

<ul>
<li>同步调用：HTTP、Thrift<br /></li>
<li>异步、消息机制：JMS、AMQP、Zeromq<br /></li>
<li>API网关需要这些服务通讯，也应支持上诉通讯机制<br /></li>
</ul></li>
<li>服务发现<br />

<ul>
<li>客户端发现：先请求服务地址列表，然后选择调用，负载均衡在客户端<br /></li>
<li>服务端发现：注册总心选好后发给客户端，负载均衡在服务端<br /></li>
<li>（这里的客户端指API网关）<br /></li>
</ul></li>
<li>处理部分失败<br />

<ul>
<li>面对服务慢或者不可用的处理。核心是不能阻塞API网关<br /></li>
<li>要根据服务是否重要，选择：<br />

<ul>
<li>直接返回给客户端错误<br /></li>
<li>返回空、默认值、缓存值、备份数据等<br /></li>
</ul></li>
<li>技术选型：Netflix Hystrix<br />
<br /></li>
</ul></li>
</ol>

<h2 id="进程间通讯-ipc">进程间通讯 IPC</h2>

<h3 id="交互风格">交互风格</h3>

<table>
<thead>
<tr>
<th></th>
<th>一对一</th>
<th>一对多</th>
</tr>
</thead>

<tbody>
<tr>
<td>同步</td>
<td>Request/Response</td>
<td>&ndash;</td>
</tr>

<tr>
<td>异步</td>
<td>Notification</td>
<td>Publish/Subscribe</td>
</tr>

<tr>
<td></td>
<td>Request/Async response</td>
<td>Public/Async responses</td>
</tr>
</tbody>
</table>

<ol>
<li>Request/Response: 发送请求，等待响应。应有超时。线程阻塞<br /></li>
<li>Notification (单向请求): 发送请求，不期待有响应<br /></li>
<li>Request/Async response: 发送请求，不期待有即时响应。线程不阻塞<br /></li>
<li>Publish/Subscribe: 发布请求，多个消费者消费<br /></li>
<li>Publish/Async responses: 发布请求，等待多个响应。有超时<br />
<br /></li>
</ol>

<h3 id="接口设计">接口设计</h3>

<ol>
<li>基于消息：定义消息channel和消息类型<br /></li>
<li>基于HTTP：定义URL、请求和响应格式<br />
<br /></li>
</ol>

<h3 id="接口升级">接口升级</h3>

<ol>
<li>向前兼容的小升级，比如增加/删除请求/响应字段：<br />

<ul>
<li>缺失的字段采用默认值，忽略额外的字段<br /></li>
<li>消息格式要支持，比如Protobuf，Json<br /></li>
</ul></li>
<li>大的升级：要使用版本区分，服务要在一段时间内同时支持新旧版本接口<br />
<br /></li>
</ol>

<h3 id="处理部分失败">处理部分失败</h3>

<ul>
<li>一定要有超时，不能无限阻塞<br /></li>
<li>要限制客户端向同一服务的请求的数量，如果超限，直接失败<br /></li>
<li>船舱隔离模式：<br />

<ul>
<li>不同的调用分配到不同的线程池，不能因为慢速调用占满快速调用的线程池<br /></li>
</ul></li>
<li>电路熔断器模式：<br />

<ul>
<li>连续超时：断开<br /></li>
<li>等待一段时间：半开放<br />

<ul>
<li>又有超时：再断开<br /></li>
<li>或不再超时：恢复<br /></li>
</ul></li>
</ul></li>
<li>要根据服务是否重要，选择：<br />

<ul>
<li>直接返回给客户端错误<br /></li>
<li>返回空、默认值、缓存值、备份数据等<br />
<br /></li>
</ul></li>
</ul>

<h3 id="ipc技术">IPC技术</h3>

<h4 id="异步-基于消息的通讯">异步、基于消息的通讯</h4>

<p>关键字：消息头、消息体、频道、生产者、消费者、broker、点对点、发布/订阅、……<br />
这里不展开</p>

<ul>
<li>好处<br />

<ol>
<li>客户端和服务解耦。客户端也不需要使用服务发现机制<br /></li>
<li>消息缓存。支持消费者不实时在线<br /></li>
<li>支持上面提到的所有交互风格<br /></li>
<li>是显式IPC，不像有些RPC机制，尝试屏蔽是远程调用的事实。开发者有更好的意识和控制权<br /></li>
</ol></li>
<li>缺点<br />

<ol>
<li>额外的操作复杂性，需要引入一个高可用的消息中间件（这个应该不是问题）<br /></li>
<li>用来实现Request/Response比较复杂：<br />

<ul>
<li>客户端的请求消息要带上响应的channel和唯一id<br /></li>
<li>服务的响应消息要带上这个唯一id，发送到响应channel<br /></li>
<li>客户端要用唯一id，从响应channel找到匹配响应消息<br /></li>
<li>不难理解，但是确实比直接基于请求/响应的机制更复杂<br />
<br /></li>
</ul></li>
</ol></li>
</ul>

<h4 id="同步-基于请求-响应的通讯">同步、基于请求/响应的通讯</h4>

<ul>
<li>REST<br />

<ul>
<li>核心是“资源”，基于HTTP请求类型和参数，实现资源的“增删改查”<br /></li>
<li>REST定义也有不同的级别，从POST到同一URL，靠参数指定操作和对象，到靠HTTP请求类型指定操作，不同URL指定操作对象。不绝对<br /></li>
<li>优势<br />

<ul>
<li>基于HTTP，简单熟悉<br /></li>
<li>构造请求简单，测试方便<br /></li>
<li>天然支持请求/响应模式<br /></li>
<li>防火墙友好<br /></li>
<li>无中间层，系统结构简单<br /></li>
</ul></li>
<li>缺点<br />

<ul>
<li>对逻辑上的单向请求（Notification），服务端也要发响应<br /></li>
<li>服务端必须实时在线<br /></li>
<li>客户端和服务端耦合。需要有服务发现机制<br /></li>
</ul></li>
<li>IDL：RAML和Swagger<br /></li>
</ul></li>
<li>Thrift<br />

<ul>
<li>支持请求/响应和通知（单向）<br /></li>
<li>支持Json、二进制和压缩二进制。取舍是人工可读和占空间大小<br /></li>
<li>支持HTTP和TCP。取舍是是否防火墙友好和效率<br />
<br /></li>
</ul></li>
</ul>

<h2 id="服务发现">服务发现</h2>

<h3 id="为什么需要服务发现">为什么需要服务发现</h3>

<ol>
<li>集群动态伸缩<br /></li>
<li>基于Container的部署方式，IP和端口也是动态分配的<br />
<br /></li>
</ol>

<h3 id="服务发现方式">服务发现方式</h3>

<ol>
<li>客户端发现模式<br />

<ol>
<li>服务端在启动时向注册中心注册、停止时取消注册、靠心跳刷新<br /></li>
<li>客户端向注册中心获取服务端列表<br /></li>
<li>客户端主动负载均衡，比如采用一致性hash<br /></li>
<li>优点：直接<br /></li>
<li>优点：可根据业务灵活选用负载均衡策略<br /></li>
<li>缺点：客户端和注册中心耦合<br /></li>
<li>实现技巧：客户端和服务端均在注册中心注册，便于服务端变更时，注册中心主动推送。参考dubbo<br /></li>
</ol></li>
<li>服务端发现模式<br />

<ol>
<li>客户端请求发给负载均衡服务器<br /></li>
<li>负载均衡服务器负责和注册中心通讯<br /></li>
<li>优点：客户端和服务发现逻辑解耦<br /></li>
<li>缺点：需要高可用的负载均衡服务器<br />
<br /></li>
</ol></li>
</ol>

<h3 id="注册中心">注册中心</h3>

<p>参考：Zookeeper<br />
注册方式：<br />
1. 自注册：优点：直接；缺点：服务和注册中心耦合<br />
2. 第三方组件注册：优点：解耦；缺点：额外高可用组件</p>

<h2 id="事件驱动数据模型">事件驱动数据模型</h2>

<p>数据随着微服务拆分，带来下面的挑战：<br />
1. 跨服务事务的一致性<br />
    - 2PC 两阶段提交在此情况下不可用，CAP要优先满足A，或者BASE<br />
2. 怎样从多个服务请求数据</p>

<h3 id="事件驱动架构">事件驱动架构</h3>

<ol>
<li>将跨服务的事务划分为多步<br /></li>
<li>每一步，一个微服务更新业务对象（本地事务），同时产生一个事件以激发下一步<br /></li>
<li>事件通过消息系统传递<br />
<br /></li>
</ol>

<p>例子：创建订单<br />
1. 订单服务创建订单，状态为NEW，然后发布订单创建消息到消息系统<br />
2. 客户服务收到订单创建消息，预留订单费用，发布预留订单费用消息<br />
    - 预留费用至少涉及到两个表，是一个本地事务。要能想到<br />
    - 1. <code>customer.credit_limit - sum(reserved_credit.amount) &gt;= order_total</code><br />
    - 2. <code>insert into reserved_credit (... amount) values (... order_total)</code><br />
    - 如果要保证事务发送成功，事务里还要包括第3个表，事务表（见下）<br />
    - 
<figure >
    <a href="Richardson-microservices-part5-credit-check-2-e1449727579423.png">
        <img src="Richardson-microservices-part5-credit-check-2-e1449727579423.png" />
    </a>
    
</figure>
<br />
3. 订单服务收到预留订单费用消息，将订单状态更新为OPEN</p>

<p>因为服务统一向消息系统发事务，可以有一个视图服务，订阅这些事务，更新事务，实现跨服务查询</p>

<h3 id="原子性">原子性</h3>

<ol>
<li>使用本地事务发布事件<br />

<ul>
<li>将操作业务对象和插入事件表放到一个事务里面<br /></li>
<li>
<figure >
    <a href="Richardson-microservices-part5-local-transaction-e1449727484579.png">
        <img src="Richardson-microservices-part5-local-transaction-e1449727484579.png" />
    </a>
    
</figure>
<br /></li>
<li>事件发布者轮询事件表，确保事件发送成功 at least once<br /></li>
</ul></li>
<li>挖掘数据库事务日志<br />

<ul>
<li>实现较复杂<br /></li>
</ul></li>
<li>使用事件源<br />

<ul>
<li>保存的不是结果，而是操作步骤<br /></li>
<li>逻辑较复杂<br />
<br /></li>
</ul></li>
</ol>

<h2 id="部署">部署</h2>

<ol>
<li>每微服务一虚拟机<br />

<ul>
<li>隔离性高<br /></li>
<li>开销大<br /></li>
</ul></li>
<li>每微服务一容器<br />

<ul>
<li>隔离性低<br /></li>
<li>开销小<br /></li>
<li>实现：Docker<br />
<br /></li>
</ul></li>
</ol>

<h2 id="重构单一架构到微服务架构">重构单一架构到微服务架构</h2>

<ol>
<li>新功能直接使用微服务实现<br />

<ul>
<li>前端路由请求到旧单一应用和新微服务<br /></li>
<li>新微服务使用“胶水代码”访问旧单一应用<br /></li>
<li>访问旧单一应用的数据<br />

<ul>
<li>远程调用旧单一应用接口<br /></li>
<li>直接访问旧单一应用数据库<br /></li>
<li>维护独立数据，和旧数据库同步<br /></li>
</ul></li>
</ul></li>
<li>拆分前后端<br />

<ul>
<li>最容易拆的是表现层和逻辑层。逻辑层和数据层稍难<br /></li>
<li>表现层拆出来后便于独立开发和A/B测试<br /></li>
</ul></li>
<li>拆模块<br />

<ul>
<li>优先级<br />

<ul>
<li>先拆变化频繁的，便于加速后继开发<br /></li>
<li>再拆资源要求不一样的，便于分开部署和伸缩<br /></li>
<li>再拆和其它模块交互较粗的，比如通过消息系统交互的<br /></li>
</ul></li>
<li>步骤<br />

<ol>
<li>模块和剩余部分改成IPC通讯<br /></li>
<li>将模块独立成微服务<br /></li>
</ol></li>
</ul></li>
</ol>


            <aside>
                
                
<div id="disqus_thread"></div>
<script>
    

    

    (function() {  
        var d = document, s = d.createElement('script');
        
        s.src = '//.disqus.com/embed.js';
        
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>


            </aside>
        </article>

    </div>
    <aside class="col-md-4">

    

    

    
    
    <div class="well">
        <h3 class="text-capitalize">categories</h3>
        <ul class="list-unstyled">
        
            <li><a href="/categories/java">Java</a></li>
        
            <li><a href="/categories/network">Network</a></li>
        
            <li><a href="/categories/service">Service</a></li>
        
            <li><a href="/categories/utility">Utility</a></li>
        
            <li><a href="/categories/web">Web</a></li>
        
        </ul>
    </div>
    
    
    
    <div class="well">
        <h3 class="text-capitalize">tags</h3>
        <ul class="list-unstyled">
        
            <li><a href="/tags/dispatcherservlet">DispatcherServlet</a></li>
        
            <li><a href="/tags/docker">Docker</a></li>
        
            <li><a href="/tags/dubbo">Dubbo</a></li>
        
            <li><a href="/tags/gc">GC</a></li>
        
            <li><a href="/tags/http">HTTP</a></li>
        
            <li><a href="/tags/high-concurrency">High-Concurrency</a></li>
        
            <li><a href="/tags/jvm">JVM</a></li>
        
            <li><a href="/tags/java">Java</a></li>
        
            <li><a href="/tags/microservices">Microservices</a></li>
        
            <li><a href="/tags/nio">NIO</a></li>
        
            <li><a href="/tags/network">Network</a></li>
        
            <li><a href="/tags/restful">RESTful</a></li>
        
            <li><a href="/tags/soa">SOA</a></li>
        
            <li><a href="/tags/service">Service</a></li>
        
            <li><a href="/tags/servlet">Servlet</a></li>
        
            <li><a href="/tags/servlet-container">Servlet-Container</a></li>
        
            <li><a href="/tags/spring">Spring</a></li>
        
            <li><a href="/tags/tcp-ip">TCP-IP</a></li>
        
            <li><a href="/tags/uml">UML</a></li>
        
            <li><a href="/tags/utility">Utility</a></li>
        
            <li><a href="/tags/web">Web</a></li>
        
            <li><a href="/tags/web-server">Web-Server</a></li>
        
        </ul>
    </div>
    
    

</aside>

</div>
            <footer>
                <div class="row">
                    <div class="col-lg-12">
                        <p>
                            <span id="copyright">&copy;</span>
                            
                                2017
                            
                            
                                <a href="https://creativecommons.org/licenses/by-sa/4.0/">CC-BY-SA</a> -
                            
                                nf_xp
                                <br />
                            
                                Template by <a href="https://github.com/Fale/fale.io">fale.io</a> -
                            
                            
                                Theme by <a href="https://github.com/Fale/bootstrap2hugo">bootstrap2hugo</a> -
                            
                            Powered by <a href="http://gohugo.io" target="_blank">Hugo</a><br />
                        </p>
                    </div>
                </div>
            
            </footer>
        </div>

        <script src="/js/jquery-3.1.1.min.js"></script>
        <script src="/js/bootstrap-3.3.7.min.js"></script>
        <script type="text/javascript">
            (function() {
                var css = document.createElement('link');
                css.href = '/css/font-awesome-4.7.0.min.css';
                css.rel = 'stylesheet';
                css.type = 'text/css';
                document.getElementsByTagName('head')[0].appendChild(css);
            })();
        </script>
        <script src="/js/highlight-9.10.0.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

<script type="text/javascript" src="https://cdn.rawgit.com/knsv/mermaid/6.0.0/dist/mermaid.min.js"></script>
<script>mermaid.initialize({startOnLoad:true});</script>

        <script>
(function() {
  if (window.location.hostname === "localhost") {
    console.log("Local dev, so no Google Analytics.");
    return;
  } else {
    (function(i, s, o, g, r, a, m) {
      i['GoogleAnalyticsObject'] = r;
      i[r] = i[r] || function() {
        (i[r].q = i[r].q || []).push(arguments)
      }, i[r].l = 1 * new Date();
      a = s.createElement(o),
        m = s.getElementsByTagName(o)[0];
      a.async = 1;
      a.src = g;
      m.parentNode.insertBefore(a, m)
    })(window, document, 'script', '//www.google-analytics.com/analytics.js', 'ga');

    ga('create', '', 'auto');
    ga('set', 'anonymizeIp', true);
    ga('send', 'pageview');
  }
})();
</script>

    </body>
</html>

