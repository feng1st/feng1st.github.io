<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on 知耻而后勇，知不足而后进</title>
    <link>https://feng1st.github.io/post/index.xml</link>
    <description>Recent content in Posts on 知耻而后勇，知不足而后进</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>utf-8</language>
    <copyright>nf_xp</copyright>
    <lastBuildDate>Wed, 14 Jun 2017 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://feng1st.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Tomcat笔记</title>
      <link>https://feng1st.github.io/post/2017-06-14-tomcat/</link>
      <pubDate>Wed, 14 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>https://feng1st.github.io/post/2017-06-14-tomcat/</guid>
      <description>

&lt;h2 id=&#34;架构&#34;&gt;架构&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Server: 整个容器&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Service: 关联Container和Connector的中间人，包含一个Container和多个Connector&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Connector: 负责和客户端的网络通讯，接受/建立连接，接收请求，返回响应&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;维持一个一定大小的线程池，创建多个Processor，当请求来的时候，将socket和processor绑定，然后运行&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Request, Response是在这里创建的，然后传递给Container&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;低版本Tomcat可以修改配置文件server.xml，为Connector使用&lt;code&gt;protocol=&amp;quot;org.apache.coyote.http11.Http11NioProtocol&amp;quot;&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Container: 所有容器的父接口，下面4个重要的实现类/子接口&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;Engine, Host, Context, Wrapper&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;4个之间不是并列关系，是父子包含关系&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Engine: 是一个Service的根容器，处理请求的总管道 Pipeline&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Host: Engine的子容器，负责处理访问某特定host的请求。还实现了Deployer接口，实现应用程序的展开、部署、启动&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Context: Host的子容器，负责处理访问某特定路径 path 的请求。也是我们的单个应用程序的单位&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Wrapper: Context的子容器，负责调用Filter和Servlet&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;LifeCycle: 生命周期管理，包括父容器启动时，分别启动子容器。父容器结束前，分别结束子容器&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Pipeline: Valve的容器，请求传递的责任链。Pipeline内的Valve依次调用，最后一个Valve调用下一层级的Pipeline&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;EngineValve1 -&amp;gt; EngineValve2 -&amp;gt; ... -&amp;gt; StandardEngineValve -&amp;gt; HostPipeline&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Valve: Pipeline的切入点&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;StandardEngineValve: Engine pipeline上最后一个valve，调用Host&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;StandardHostValve: Host pipeline上最后一个valve，调用Context&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;StandardContextValve: Context pipeline上最后一个valve，调用Wrapper&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;StandardWrapperValve: Wrapper pipeline上最后一个valve，负责生成并调用filterChain，最后调用servlet&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;处理请求&#34;&gt;处理请求&lt;/h2&gt;

&lt;p&gt;时序图见&lt;a href=&#34;http://tomcat.apache.org/tomcat-9.0-doc/architecture/requestProcess/request-process.png&#34;&gt;这里&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;classloader&#34;&gt;ClassLoader&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;是典型的双亲委托模式 Parents Delegation Model&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;要求：&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;common目录下的类被Tomcat和应用使用&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;server目录下的类只被Tomcat使用&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;shared目录下的类可以被所有应用使用&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;应用目录下的类只可以被本应用使用&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;实现（ClassLoader层级关系）：&lt;br /&gt;
&lt;div class=&#34;mermaid&#34;&gt;
graph RL
    commonLoader--&gt;systemLoader
    catalinaLoader--&gt;commonLoader
    sharedLoader--&gt;commonLoader
    webAppLoader1--&gt;sharedLoader
    webAppLoader2--&gt;sharedLoader
    
&lt;/div&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Jetty笔记</title>
      <link>https://feng1st.github.io/post/2017-06-12-jetty/</link>
      <pubDate>Mon, 12 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>https://feng1st.github.io/post/2017-06-12-jetty/</guid>
      <description>

&lt;h2 id=&#34;核心组成部分&#34;&gt;核心组成部分&lt;/h2&gt;

&lt;div class=&#34;mermaid&#34;&gt;
graph LR
L(LifeCycle)
C(Connector)---S(Server)
H(Handler)---S
S---P(ThreadPool)

&lt;/div&gt;


&lt;h2 id=&#34;lifecycle&#34;&gt;LifeCycle&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;start();
stop();
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;管理server对象的生命周期&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Connector, Handler, ThreadPool都实现了LifeCycle接口&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;LifeCycle的监听使用了观察者模式&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;connector&#34;&gt;Connector&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;接受TCP连接&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;用配置的ConnectionFactory创建Connection，和连接绑定&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;可配置多个ConnectionFactory，链式调用，分别完成各自一层的工作，比如：&lt;br /&gt;

&lt;ol&gt;
&lt;li&gt;ProxyConnectionFactory：处理Proxy协议&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;SslConnectionFactory：SSL加密解密&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;HttpConnectionFactory：处理实际的HTTP请求&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;handler&#34;&gt;Handler&lt;/h2&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;http://www.eclipse.org/jetty/documentation/current/images/basic-architecture-handlers.png&#34; /&gt;
    
    
&lt;/figure&gt;


&lt;ol&gt;
&lt;li&gt;Jetty用一个Handler模型就完成了请求在整个server的不同层级的处理，这个是Jetty保持轻量和容易扩展的原因，这里说一下它的设计模式。&lt;br /&gt;

&lt;ol&gt;
&lt;li&gt;HandlerWrapper：形式上是装饰者模式，使用方式上是责任链模式&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;装饰者模式 Decorator：实现对所包装对象在本层级的拦截。比如，SessionHandler处理Session，SecurityHandler处理安全验证后，再调用被包装Handler的handle()&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;责任链模式 Chain of Responsibility：已经提到过，调用被包装Handler的handle()，实现责任链&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;HandlerContainer：组合模式 Composite，树形结构&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;模板方法 Template Method：比如ScopedHandler.doScope()，更清晰的向使用者阐述类的职责&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;门面模式 Facade：Context相关类，限制暴露方法的范围&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;Handler风格分类：&lt;br /&gt;

&lt;ol&gt;
&lt;li&gt;协调型，路由请求到其它Handler（HandlerCollection, ContextHandlerCollection）&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;过滤型，拦截修改到其它Handler的请求（HandlerWrapper, SessionHandler, ContextHandler）&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;处理型，处理请求，生成响应（StaticHandler, ServletHandler）&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;调用方式：&lt;br /&gt;

&lt;figure &gt;
    
        &lt;img src=&#34;http://www.eclipse.org/jetty/documentation/current/images/basic-architecture-nested-handlers.png&#34; /&gt;
    
    
&lt;/figure&gt;
&lt;br /&gt;

&lt;ol&gt;
&lt;li&gt;顺序调用，代表：HandlerCollection&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;嵌套调用，代表：HandlerWrapper&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;servlethandler&#34;&gt;ServletHandler&lt;/h2&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;http://www.eclipse.org/jetty/documentation/current/images/basic-architecture-servlet-handler.png&#34; /&gt;
    
    
&lt;/figure&gt;


&lt;ol&gt;
&lt;li&gt;ServletHandler持有多个FilterHolder和ServletHolder&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;作为Servlet容器，调用时先调用所有的Filter，再调用Servlet&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;context&#34;&gt;Context&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;简单的说，分组环境变量&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;几个时序图&#34;&gt;几个时序图&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Jetty启动&lt;br /&gt;

&lt;figure &gt;
    
        &lt;img src=&#34;https://www.ibm.com/developerworks/cn/java/j-lo-jetty/image011.jpg&#34; /&gt;
    
    
&lt;/figure&gt;
&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;先启动线程池，再启动Handler，最后Connector。前者是处理后者的前提。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Jetty建立连接&lt;br /&gt;

&lt;figure &gt;
    
        &lt;img src=&#34;https://www.ibm.com/developerworks/cn/java/j-lo-jetty/image013.jpg&#34; /&gt;
    
    
&lt;/figure&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Jetty处理连接&lt;br /&gt;

&lt;figure &gt;
    
        &lt;img src=&#34;https://www.ibm.com/developerworks/cn/java/j-lo-jetty/image015.jpg&#34; /&gt;
    
    
&lt;/figure&gt;
&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;注意Request/Response是在什么地方创建的&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;引用来源&#34;&gt;引用来源&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://www.eclipse.org/jetty/documentation/current/architecture.html&#34;&gt;http://www.eclipse.org/jetty/documentation/current/architecture.html&lt;/a&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.ibm.com/developerworks/cn/java/j-lo-jetty/&#34;&gt;https://www.ibm.com/developerworks/cn/java/j-lo-jetty/&lt;/a&gt;&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Servlet笔记</title>
      <link>https://feng1st.github.io/post/2017-06-11-servlet/</link>
      <pubDate>Sun, 11 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>https://feng1st.github.io/post/2017-06-11-servlet/</guid>
      <description>

&lt;p&gt;教程：&lt;br /&gt;
&lt;a href=&#34;http://tutorials.jenkov.com/java-servlets/&#34;&gt;http://tutorials.jenkov.com/java-servlets/&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;一些思考点&#34;&gt;一些思考点&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Servlet的生命周期是怎样被&lt;strong&gt;容器&lt;/strong&gt;管理的？&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Session是怎样被管理和传递的？&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;分布式环境下Session是怎样被管理的？&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;ServletContext是怎样被管理和传递的，典型用途是什么？&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;为什么要使用RequestDispatcher，而不是，比如直接调用其它Servlet？&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Filter和Servlet有什么异同？&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Filter和Servlet分属不同两个类，为什么filterChain.doFilter()能把请求传递给Servlet&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;怎样用Filter实现GZip，这个实现和AOP有什么区别？&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Session和ServletContext是线程安全的吗？&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Java NIO摘要</title>
      <link>https://feng1st.github.io/post/2017-06-10-java-nio/</link>
      <pubDate>Sat, 10 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>https://feng1st.github.io/post/2017-06-10-java-nio/</guid>
      <description>

&lt;p&gt;比较经典和精简的教程，先直接发链接：&lt;br /&gt;
&lt;a href=&#34;http://tutorials.jenkov.com/java-nio/&#34;&gt;http://tutorials.jenkov.com/java-nio/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;NIO的实现不复杂，但是其体现了一个统一、可伸缩的面向数据/信息流的设计思想&lt;br /&gt;
例如，换用消息队列，就可以扩展到分布式系统里去&lt;/p&gt;

&lt;h2 id=&#34;一些思考点&#34;&gt;一些思考点&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Channel和Stream有什么不同？&lt;br /&gt;

&lt;ol&gt;
&lt;li&gt;Channel双向，Stream一般单向&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Channel支持异步&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Channel搭配Buffer使用&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;ServerSocketChannel和SocketChannel有什么不同？&lt;br /&gt;

&lt;ol&gt;
&lt;li&gt;SocketChannel用于单个连接&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;ServerSocketChannel用于监听端口，对每一个接受的连接创建一个SocketChannel&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;FileChannel.transferTo(&amp;hellip;, SocketChannel)有什么需要注意的？&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;SocketChannel非阻塞且发送缓冲已满，可能只传输部分&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;SocketChannel的blocking和non-blocking模式有什么不同？&lt;br /&gt;

&lt;ol&gt;
&lt;li&gt;相对于阻塞，connect()直接返回，需要后继调用finishConnect()判断成功&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;write()/read()可能未实际读写就返回&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;ServerSocketChannel的blocking和non-blocking模式有什么不同？&lt;br /&gt;

&lt;ol&gt;
&lt;li&gt;相对于阻塞，accept()直接返回，如没有接受连接，返回null&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;write()/read()可能未实际读写就返回&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;Blocking模式Socket有什么问题？&lt;br /&gt;

&lt;ol&gt;
&lt;li&gt;一般会用一个线程处理一个连接，所以支撑的连接数非常有限&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;如果使用连接池复用活动连接，一些慢速或者非活动连接可能会占满连接池&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;Non-blocking模式Socket有哪些挑战？&lt;br /&gt;

&lt;ol&gt;
&lt;li&gt;读到的字节流拆分Message：文章提到了TLV，但最好用长度+内容+校验构成&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;长度：TLV中的L&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;内容：类型是包含在这里面的，比如protobuf协议&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;校验：用于验证数据错误，或者网络错误，通知重传&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;读写的Message要有长度限制，否则一个伪造的字节流就能把服务器撑垮&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;一般会定义一种特定Message，专门用来拆分大的其它Message，长度和校验部分机制不变，内容部分构成如下&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;总段数&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;本段序号&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;本段内容&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;发送方不能把所有的Channel都注册到Selector，因为Selector.select()时，可能大部分Channel都可写，全部返回，性能低下&lt;br /&gt;

&lt;ol&gt;
&lt;li&gt;当本Channel对应缓冲区有待发送数据时，才注册到Selector&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;当缓冲区数据发送完毕时，从Selector取消注册&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;Selector有哪两种底层实现？&lt;br /&gt;

&lt;ol&gt;
&lt;li&gt;Reactor：轮询Channel对应底层IO句柄。当连接数过多时，性能低下。这个可以算是多路复用，因为select()时还是有等待的过程&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;e-poll：注册回调函数，只有当有对应事件发生时，才通知Selector。这个算是真正的异步。Linux直接支持&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;阻塞/非阻塞，同步/异步&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;阻塞：调用io函数会一直等待，比如System.in.read()&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;非阻塞：调用io函数，只读写可以读写的部分，然后立刻返回，比如NIO&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;同步：用等待或者轮询的方式拿到结果，比如NIO&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;异步：当时不用拿到结果，事后再获取结果，或者等到结果通知。使用Future或者Callback，比如AsynchronousFileChannel&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>HTTP协议摘要</title>
      <link>https://feng1st.github.io/post/2017-06-09-http-protocol/</link>
      <pubDate>Fri, 09 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>https://feng1st.github.io/post/2017-06-09-http-protocol/</guid>
      <description>

&lt;h2 id=&#34;http协议概述&#34;&gt;HTTP协议概述&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;基于服务器/客户端，请求/响应&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;无连接（1.1开始支持长连接Web Socket）&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;无状态（需要依赖会话维持状态）&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;应用层协议，基于TCP&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;url&#34;&gt;URL&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;http://host:port/res_uri.html?param=...&lt;/code&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;协议：如http, https, ftp等&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;用户名/密码：部分协议例如ftp支持用户名密码&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;域名和端口：要访问服务器的域名和端口，不同协议有自己的默认端口&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;访问资源：要访问资源的路径和参数&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;请求&#34;&gt;请求&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;GET /index.html HTTP/1.0&amp;lt;CRLF&amp;gt;
Host:www.sina.com.cn&amp;lt;CRLF&amp;gt;
Accept-Encoding:gzip, deflate&amp;lt;CRLF&amp;gt;
User-Agent:Mozilla/4.0(compatible;MSIE6.0;Windows NT 5.0)&amp;lt;CRLF&amp;gt;
Connection:Keep-Alive&amp;lt;CRLF&amp;gt;
&amp;lt;CRLF&amp;gt;
{Optional Content Body}
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;起始行：Method Request-URI HTTP-Version&lt;CRLF&gt;&lt;br /&gt;

&lt;ol&gt;
&lt;li&gt;请求方法&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;GET 请求Request-URI所标识的资源&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;POST 在资源后附加新的数据&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;HEAD 请求获取资源的响应消息报头&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;PUT 请求服务器存储一个资源&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;DELETE 请求删除资源&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;TRACE 请求服务器回送收到的请求信息，用于诊断测试&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;CONNECT 保留字&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;OPTIONS 请求查询服务器性能&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;消息报头：（见后）&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;消息主体：可选，对POST请求，消息主体为POST的数据&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;响应&#34;&gt;响应&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;HTTP/1.1 200 OK&amp;lt;CRLF&amp;gt;
Content-Length:123&amp;lt;CRLF&amp;gt;
Content-Type:text/html;charset=utf-8&amp;lt;CRLF&amp;gt;
...&amp;lt;CRLF&amp;gt;
&amp;lt;CRLF&amp;gt;
{Optional Content Body}
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;起始行：HTTP-Version Status-Code Reason-Phrase&lt;CRLF&gt;&lt;br /&gt;

&lt;ol&gt;
&lt;li&gt;状态码&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;1xx：指示信息&amp;ndash;消息已接收，继续处理&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;2xx：成功&amp;ndash;消息已被成功接收、理解、接受&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;200 OK&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;3xx：重定向&amp;ndash;要完成请求必须进行进一步的操作&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;4xx：客户端错误&amp;ndash;请求有语法错误或者请求无法实现&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;400 Bad Request&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;401 Unauthorized&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;403 Forbidden&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;404 Not Found&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;5xx：服务端错误&amp;ndash;服务端无法实现请求&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;500 Internal Server Error&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;503 Server Unavailable&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;消息报头：（见下）&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;消息主体：可选，返回的内容&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;消息报头&#34;&gt;消息报头&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;常见请求报文头信息&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Accept:text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8
Accept-Encoding:gzip, deflate, sdch, br
Accept-Language:en-US,en;q=0.8
Cache-Control:max-age=0
Connection:keep-alive
Cookie:BAIDUID=BDE50BA6209B0C5BC935D4BBF631F90D:FG=1; pgv_pvi=5348235264
Host:www.baidu.com
User-Agent:Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Ubuntu Chromium/58.0.3029.110 Chrome/58.0.3029.110 Safari/537.36
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;常见响应头信息&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Cache-Control:private
Connection:keep-alive
Content-Encoding:gzip
Content-Type:text/html; charset=utf-8
Date:Fri, 09 Jun 2017 09:08:42 GMT
Expires:Fri, 09 Jun 2017 09:08:42 GMT
Server:bfe/1.0.8.18
Set-Cookie:BDSVRTM=9; path=/
Set-Cookie:BD_HOME=0; path=/
Set-Cookie:H_PS_PSSID=1461_21094_17001_20929; path=/; domain=.baidu.com
Set-Cookie:__bsi=12742868508732542774_00_0_I_R_15_0303_C02F_N_I_I_0; expires=Fri, 09-Jun-17 09:08:47 GMT; domain=www.baidu.com; path=/
Strict-Transport-Security:max-age=172800
Transfer-Encoding:chunked
Vary:Accept-Encoding
X-Powered-By:HPHP
X-UA-Compatible:IE=Edge,chrome=1
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;浏览器打开网页完整过程&#34;&gt;浏览器打开网页完整过程&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;浏览器解析用户输入的URL&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;如果是输入的域名，则需要向DNS请求实际IP地址&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;DNS有缓存&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;DNS服务器如果本身没有数据，有一个向上级DNS服务器请求的过程&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;DNS解析一般会根据请求所在地区、网络（电信、联通）进行初步的负载均衡，返回一个相对较快的IP&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;拿到的IP地址，一般是一个前端服务器地址，前端服务器负责负载均衡，会为你分配一台服务器处理你的请求&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;负载均衡一般由LVS (Linux Virtual Server)，或者自定义服务实现&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;服务器会解析你的请求，处理请求，生成数据，渲染页面，返回页面&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;一般使用MVC框架&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;处理请求的过程一般不会是单台服务器能完成的，这里涉及到分布式集群、服务中间件、缓存、数据库、消息队列、日志等概念&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;请求一般分为搜索、事务&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;搜索：底层有一个分布式数据库建索引库的问题，上层有一个中文分词的问题&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;事务：购买、支付等都是事务，要保证事务在分布式环境中的完整性&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;用户访问的全部信息，可以被保存，用于数据挖掘&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;返回的页面，如果是一个重定向，浏览器会请求新的地址&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;返回的页面，如果包含资源/异步请求，浏览器会依次请求这些资源&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;返回的报文头，一般包含SessionID（一般放在Cookies里）。浏览器后继请求，会带上SessionID，用于服务器维持会话&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;会话可能会影响请求被分配处理的集群，比如，前后放在同一个机房处理，这个完全看服务端实现&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;请求的静态资源，一般会使用CDN (Content Delivery Network)，减轻主/计算服务器压力&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;如同分布式数据库，CDN有分发和同步的过程&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;浏览器拿到返回的页面（及页面内资源）后，有一个渲染的过程&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>TCP/IP协议摘要</title>
      <link>https://feng1st.github.io/post/2017-06-08-tcp-ip-protocol/</link>
      <pubDate>Thu, 08 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>https://feng1st.github.io/post/2017-06-08-tcp-ip-protocol/</guid>
      <description>

&lt;h2 id=&#34;协议分层&#34;&gt;协议分层&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;应用层 Application&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;对应OSI协议Application、Presentation、Session三层&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;常见上层协议：HTTP、FTP、SMTP、TELNET&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;传输层 Transport&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;对应OSI协议Transport层&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;协议：&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;TCP：（见下）&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;UDP：不超时重传、不错误重传、不保证顺序&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;网络层 Internet&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;对应OSI协议Network层&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;协议：&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;IP：（见下）&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;ARP：IP地址到MAC地址转换&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;DARP：（略）&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;ICMP：发生错误时，错误信息封包传给主机；IP重定向报文；路由发现报文&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;ping&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;traceroute&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;利用IP协议的TTL实现&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;利用主机不可达和端口不可达区分&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;网络接口层 Network Interface&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;对应OSI协议Data Link、Physical两层&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;附加以太网部首&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;ip协议&#34;&gt;IP协议&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;附加IP部首&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;TTL，生存周期，每路由一层减1，为0时丢弃&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;实现traceroute&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;路由顺序：&lt;br /&gt;

&lt;ol&gt;
&lt;li&gt;TTL为0时丢弃&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;匹配主机&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;匹配同子网路由器&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;匹配同网号路由器&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;匹配默认路由器&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;不保证可达，需配合ICMP由上层实现可靠性&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;tcp协议&#34;&gt;TCP协议&lt;/h2&gt;

&lt;p&gt;流量控制的思想可以用于上层应用的开发&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;附加TCP部首&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;可靠协议&lt;br /&gt;

&lt;ol&gt;
&lt;li&gt;合理分块&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;超时重发&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;校验和校验&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;发送确认&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;组装时排序&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;滑动窗口流控&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;建立连接，三次握手：&lt;br /&gt;
&lt;div class=&#34;mermaid&#34;&gt;
sequenceDiagram
    Client-&gt;&gt;Server: SYN
    Server--&gt;&gt;Client: ACK
    Client--&gt;&gt;Server: ACK
    
&lt;/div&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;断开连接，四次握手：&lt;br /&gt;
&lt;div class=&#34;mermaid&#34;&gt;
sequenceDiagram
    Client-&gt;&gt;Server: FIN
    Server--&gt;&gt;Client: ACK
    Server-&gt;&gt;Client: FIN
    Client--&gt;&gt;Server: ACK
    
&lt;/div&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;流量控制&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;延迟发送&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;捎带ACK：延迟发送ACK&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Nagle算法：延迟发送数据&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;滑动窗口 rwnd：接收方缓冲区&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;拥塞窗口 cwnd：探测带宽上限&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;慢启动阶段（未超过门限 ssthresh）&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;cwnd *= 2&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;拥塞避免阶段（超过门限）&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;cwnd += 1&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;超时重传&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;超时时间调整：简单的说，是一个涉及旧超时时间、新传输时间、经验系数、方差的函数&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;拥塞：某报文超时需要重传&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ssthresh /= 2&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cwnd = 1&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;进入慢启动阶段&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;快速重传：当收到3个重复ACK时（&lt;3个，乱序是大概率事件；&gt;=3个，丢包是大概率事件）&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ssthresh /= 2&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cwnd = ssthresh&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;进入拥塞避免阶段&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;快速恢复：（略）&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;其它计时器&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;坚持定时器：双方滑动窗口为0时的试探间隔，避免互相等待死锁&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;保活定时器：判断保持或断开半开放连接&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;2MSL定时器：端口可再次使用的计时器，在此期间，服务端可以重启而不报端口占用错误，但不可以建立连接&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Java内存模型和GC机制摘要</title>
      <link>https://feng1st.github.io/post/2017-06-07-jvm-memory-gc/</link>
      <pubDate>Wed, 07 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>https://feng1st.github.io/post/2017-06-07-jvm-memory-gc/</guid>
      <description>

&lt;h2 id=&#34;java对象&#34;&gt;Java对象&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;对象位置&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;对象实例在堆中分配&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;实例对应的类信息在方法区分配&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;对象信息&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;对象实例包含对象头和对象属性&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;对象头包含对象信息，包括分代年龄、锁信息等；还包括对方法区类信息的引用&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;类信息包含对父类/接口的引用，用于方法重载&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;对象大小&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;空对象大小等于对象头大小，在32位虚拟机占8字节，64位占16字节，开启压缩占12字节&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;引用在32位虚拟机占4字节，64位占8字节，开启压缩占4字节&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;数组类型大小要在元素类型大小上增加4字节数组长度&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;对象最终大小按8字节对齐&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;java内存区域&#34;&gt;Java内存区域&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;程序计数器 Program Counter Register&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;每线程&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;对于Java方法，记录当前字节码位置；对于Native方法，记录为Undefined&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;虚拟机栈 VM Stack&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;每线程&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;保存方法调用时的栈帧 Stack Frame&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;栈帧存放方法调用的局部变量表、操作栈、动态连接、方法出口等&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;局部变量表保存简单变量和对象的引用&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;栈帧大小在方法生存期内固定&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;如果栈深度超过虚拟机规定大小，抛出StackOverflowError&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;如果可供分配的内存不够，抛出OutOfMemoryError&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;本地方法栈 Native Method Stack&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;类似虚拟机栈&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;堆 Heap&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;线程共享&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;存储对象实例&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;是涉及GC的主要区域&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;方法区 Method Area&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;线程共享&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;保存加载的类信息（包括版本、接口、属性、方法、final常量、静态变量等）和运行时常量池 Runtime Constant Pool（包括字面常量、符号引用和直接引用）&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;在分代GC机制里，一般被成为永久代 Permanent Gen&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;对于存在大量Proxy动态类的系统，要考虑回收的问题&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;堆和栈的区别&#34;&gt;堆和栈的区别&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;栈：存放栈帧，内部包括简单变量和对象引用，在栈顶分配，后进先出，速度快&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;堆：存放对象实例，会因回收造成内存碎片，需要寻找下一个可供分配的连续空间，速度慢&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;对象访问方式&#34;&gt;对象访问方式&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;通过句柄池&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;栈或堆中的对象引用指向句柄池句柄，句柄分别指向堆中对象实例和方法区类信息&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;对象引用到句柄是多对一，句柄到对象实例是一对一，意味着对象实例因为GC移动而发生地址改变，只需要修改句柄&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;直接分配&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;栈或堆中的对象引用指向堆中的对象实例，对象实例内部指向方法区类信息&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;无中间层，较快。但是一旦对象实例移动，则需要更新所有的引用&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;HotSpot采用&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;对象生命周期&#34;&gt;对象生命周期&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;引用计数法&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;存在环状引用的问题&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;可达性分析算法&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;GC Roots&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;虚拟机栈引用的对象&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;本地方法栈引用的对象&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;方法区类静态属性引用的对象&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;方法区常量引用的对象&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;内存分代&#34;&gt;内存分代&lt;/h2&gt;

&lt;p&gt;不同对象的生存周期不同，不能因为回收短期对象，就扫描整个堆区&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;年轻代 Young Gen&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;默认分配区域&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;老年代 Old Gen&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;存放多次回收后依然幸存的对象，或者无法在年轻代分配的大对象&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;永久代 Permanent Gen&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;存放方法区内容，HotSpot采用，但计划弃用&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;回收算法&#34;&gt;回收算法&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;复制算法 Copying&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;A、B两块空间，在A块连续分配，空间不够时，将A块的存活对象依次复制到B块头部，并切换使用B块，A块清空&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;分配简单，连续分配，快；需要两倍空间，浪费；复制内容如果过大，依然会慢&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;标记-清除算法 Mark-Sweep&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;先对所有可回收对象做标记，然后再回收这些对象所占的空间&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;不需要移动，快；回收后会有内存碎片&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;标记-整理算法 Mark-Compact&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;先对所有可回收对象做标记，然后将幸存对象依次前移&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;需要移动，慢；回收后无内存碎片&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;分配机制&#34;&gt;分配机制&lt;/h2&gt;

&lt;p&gt;HotSpot中，年轻代分为1个Eden和2个Survivor。在Eden区分配对象，如果空间不足，将Eden区和活动Survivor区幸存对象，根据幸存次数，分别移至备用Survivor和老年代中，然后切换活动/备用Survivor。&lt;/p&gt;

&lt;h2 id=&#34;回收方式&#34;&gt;回收方式&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;串行 Serial&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;暂停用户线程，单线程回收&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;并行 Parallel&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;暂停用户线程，多线程并行回收&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;并发 Concurrent&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;回收线程和用户线程同时工作&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;垃圾回收器&#34;&gt;垃圾回收器&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Serial收集器&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;新生代&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;停止复制算法（停止 Stop-the-World，在垃圾回收时，暂停用户线程）&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;串行回收&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;ParNew收集器&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;新生代&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;停止复制算法&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;并行回收&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Parallel Scavenge收集器&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;新生代&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;停止复制算法&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;并行回收&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;关注吞吐量、支持自适应调节&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Serial Old收集器&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;老年代&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;停止标记整理算法&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;串行回收&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;CMS收集器Concurrent Mode Failure的后备&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Parallel Old收集器&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;老年代&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;停止标记整理算法&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;并行回收&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;搭配Parallel Scavenge收集器&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;CMS收集器&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;老年代&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;标记清除算法&lt;br /&gt;

&lt;ol&gt;
&lt;li&gt;初始标记：停止，串行，仅标记GC Roots直接引用的对象&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;并发标记：并发，从初始标记对象往下追踪&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;重新标记：停止，并行，修正并发标记期间改变的对象&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;并发清除：并发&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;并发回收会占用运行时CPU资源&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;因为是并发回收，所以要为GC期间新生成的对象预留空间，如果空间不够，会抛出Concurrent Mode Failure，回退到Serial Old收集器&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;因为是标记清除算法，如果产生的内存碎片导致可用连续空间不足，会触发一次带整理的Full GC&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;G1收集器&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;堆划分为相同的区域 Region&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;优先回收价值最大的区域&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;使用Remembered Set避免全堆扫描&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;整体为标记整理算法，区域间为复制算法&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;初始标记：停止，串行&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;并发标记：并发&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;最终标记：停止，并行&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;筛选回收：停止，并行&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;gc监控&#34;&gt;GC监控&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;jstat可以用来实时查看内存分配及GC信息&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;jmap可以dump出内存对象，供进一步分析&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Java命令行参数可以设置输出详细GC日志，供进一步分析&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>