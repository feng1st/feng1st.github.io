<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on 知耻而后勇，知不足而后进</title>
    <link>https://feng1st.github.io/post/index.xml</link>
    <description>Recent content in Posts on 知耻而后勇，知不足而后进</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>utf-8</language>
    <copyright>nf_xp</copyright>
    <lastBuildDate>Tue, 27 Jun 2017 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://feng1st.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Docker容器运行dubbo应用</title>
      <link>https://feng1st.github.io/post/2017-06-27-dubbo-in-docker/</link>
      <pubDate>Tue, 27 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>https://feng1st.github.io/post/2017-06-27-dubbo-in-docker/</guid>
      <description>&lt;p&gt;参考了这篇文章： &lt;a href=&#34;https://yq.aliyun.com/articles/60789&#34;&gt;https://yq.aliyun.com/articles/60789&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;大致步骤是一样的。但是，文章中的部署方式是，使用docker-compose，将zookeeper、provider、consumer编排在一起了。&lt;br /&gt;
它们使用的是同一个虚拟网络，provider将自己在虚拟网络里的ip注册到zookeeper，consumer能顺利访问到。&lt;/p&gt;

&lt;p&gt;但开发环境一般会分开部署，zookeeper、provider、consumer一般不在同一个网络。&lt;br /&gt;
为了让consumer能够通过provider注册到zookeeper里的ip进行访问，这里让provider直接使用host的网络，多个provider靠端口区分。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;application.properties&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;server.port=${SERVER_PORT:0}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个是用来区分spring-boot-starter-web里自带tomcat的端口&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;services.xml&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    &amp;lt;dubbo:registry protocol=&amp;quot;zookeeper&amp;quot; address=&amp;quot;${ZOO_SERVERS}&amp;quot;/&amp;gt;
    &amp;lt;dubbo:protocol name=&amp;quot;dubbo&amp;quot; port=&amp;quot;${DUBBO_PORT}&amp;quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个是用来区分provider通过dubbo协议暴露服务的端口&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;docker-compose.yml&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;version: &#39;2&#39;
services:
    provider1:
        image: provider
        restart: always
        network_mode: host
        environment:
            ZOO_SERVERS: localhost:2181,localhost:2182,localhost:2183
            DUBBO_PORT: 20880
            SERVER_PORT: 8080

    provider2:
        image: provider
        restart: always
        network_mode: host
        environment:
            ZOO_SERVERS: localhost:2181,localhost:2182,localhost:2183
            DUBBO_PORT: 20881
            SERVER_PORT: 8081
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;起了两个实例，分别占用主机网络的20880, 8080, 20881, 8081端口&lt;br /&gt;
zookeeper集群使用自己的网络，但是将端口映射到了主机的2181, 2182, 2183&lt;/p&gt;

&lt;p&gt;更复杂的部署，应考虑使用Docker Swarm&lt;/p&gt;

&lt;p&gt;还有其它一些细节，可以参考源代码：&lt;br /&gt;
&lt;a href=&#34;https://github.com/feng1st/microservices-demo&#34;&gt;https://github.com/feng1st/microservices-demo&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Spring实现RESTful Service笔记</title>
      <link>https://feng1st.github.io/post/2017-06-26-spring-rest/</link>
      <pubDate>Mon, 26 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>https://feng1st.github.io/post/2017-06-26-spring-rest/</guid>
      <description>

&lt;p&gt;来源：&lt;br /&gt;
&lt;a href=&#34;https://spring.io/guides/gs/rest-service/&#34;&gt;https://spring.io/guides/gs/rest-service/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;本文采用代码及分析的形式&lt;/p&gt;

&lt;h2 id=&#34;greetingcontroller-java&#34;&gt;GreetingController.java&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;src/main/java/hello/GreetingController.java&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package hello;

import java.util.concurrent.atomic.AtomicLong;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class GreetingController {

    private static final String template = &amp;quot;Hello, %s!&amp;quot;;
    private final AtomicLong counter = new AtomicLong();

    @RequestMapping(&amp;quot;/greeting&amp;quot;)
    public Greeting greeting(@RequestParam(value=&amp;quot;name&amp;quot;, defaultValue=&amp;quot;World&amp;quot;) String name) {
        return new Greeting(counter.incrementAndGet(),
                            String.format(template, name));
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;@RestController&lt;/code&gt;&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;整合&lt;code&gt;@Controller&lt;/code&gt;, &lt;code&gt;@ResponseBody&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@Controller&lt;/code&gt;&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;MVC里的Controller，Spring的DispatcherServlet，通过HandlerMapping，找到Controller后，将请求发送过来进行处理&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@ResponseBody&lt;/code&gt;&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;将返回的对象，通过注册的HttpMessageConverter，转换成字符串，写入Response的body里&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;对应的是&lt;code&gt;@RequestBody&lt;/code&gt;，通过Request header的Content-Type，将Request的body转换成对象&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@RequestMapping&lt;/code&gt;&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;URL到Controller类和方法的映射&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@RequestParam&lt;/code&gt;&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;URL参数到方法参数的映射&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;RestController和一般的MVC Controller最主要的不同的地方：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;RestController用Response Body返回json序列化后的对象&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;MVC Controller使用视图模板，返回ModelAndView经渲染后的HTML视图&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
&lt;figure &gt;
    &lt;a href=&#34;1353059506_5137.jpg&#34;&gt;
        &lt;img src=&#34;1353059506_5137.jpg&#34; /&gt;
    &lt;/a&gt;
    
&lt;/figure&gt;
&lt;br /&gt;
图片来源：&lt;a href=&#34;http://blog.csdn.net/cswhale/article/details/16941281&#34;&gt;http://blog.csdn.net/cswhale/article/details/16941281&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;application-java&#34;&gt;Application.java&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;src/main/java/hello/Application.java&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package hello;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class Application {

    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;@SpringBootApplication&lt;/code&gt;, 整合下列注解:&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;@Configuration&lt;/code&gt;&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;类作为Bean定义的来源，参考&lt;code&gt;AnnotationConfigApplicationContext&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@EnableAutoConfiguration&lt;/code&gt;&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;指示Spring Boot根据classpath、其它Bean和一些属性自动配置&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@EnableWebMvc&lt;/code&gt;&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;如果在classpath发现&lt;strong&gt;spring-webmvc&lt;/strong&gt;，自动启用&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;视应用为web application，并启用DispatcherServlet等关键行为&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@ComponentScan&lt;/code&gt;&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;从类所在包下扫描其它组件、配置、服务，找到其它controller&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;整个SpringBoot应用可以打包成一个单独的jar，这个特性非常有利于部署到容器&lt;/p&gt;

&lt;h2 id=&#34;依靠配置实现mvc&#34;&gt;依靠配置实现MVC&lt;/h2&gt;

&lt;p&gt;如果不使用SpringBoot，而是通过配置来实现，应该怎样做呢？&lt;br /&gt;
这个不是完全RESTful相关的，但有助于我们了解Spring的内部机制&lt;/p&gt;

&lt;p&gt;Controller接口，注意不是@Controller注解：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public interface Controller {
    ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;该方法被DispatcherServlet调用&lt;/p&gt;

&lt;p&gt;重要的实现类：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;AbstractController：检查HTTP方法，检查Session等&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;MultiActionController：在一个Controller里处理多个动作，比如对同一资源的增删改查，通过MethodNameResolver映射请求到方法&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;web.xml&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;ISO-8859-1&amp;quot;?&amp;gt;
&amp;lt;web-app xmlns=&amp;quot;http://java.sun.com/xml/ns/j2ee&amp;quot;
  xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot;
  xsi:schemaLocation=&amp;quot;http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-app_2_5.xsd&amp;quot;
  version=&amp;quot;2.5&amp;quot;&amp;gt;
&amp;lt;servlet&amp;gt;
     &amp;lt;servlet-name&amp;gt;dispatcherServlet&amp;lt;/servlet-name&amp;gt;
     &amp;lt;servlet-class&amp;gt;org.springframework.web.servlet.DispatcherServlet&amp;lt;/servlet-class&amp;gt;
     &amp;lt;init-param&amp;gt;
           &amp;lt;param-name&amp;gt;contextConfigLocation&amp;lt;/param-name&amp;gt;
           &amp;lt;param-value&amp;gt;/WEB-INF/dispatcherServlet-servlet.xml&amp;lt;/param-value&amp;gt;
     &amp;lt;/init-param&amp;gt;
     &amp;lt;load-on-startup&amp;gt;1&amp;lt;/load-on-startup&amp;gt;
&amp;lt;/servlet&amp;gt;
&amp;lt;servlet-mapping&amp;gt;
     &amp;lt;servlet-name&amp;gt;dispatcherServlet&amp;lt;/servlet-name&amp;gt;
     &amp;lt;url-pattern&amp;gt;*.do&amp;lt;/url-pattern&amp;gt;
&amp;lt;/servlet-mapping&amp;gt;
&amp;lt;/web-app&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;所有以.do结尾的请求，都将被DispatcherServlet处理&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;dispatcherServlet-servlet.xml&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;!DOCTYPE beans PUBLIC &amp;quot;-//SPRING//DTD BEAN 2.0//EN&amp;quot;
&amp;quot;http://www.springframework.org/dtd/spring-beans-2.0.dtd&amp;quot;&amp;gt;
&amp;lt;beans&amp;gt;
     &amp;lt;bean id=&amp;quot;urlMapping&amp;quot; class=&amp;quot;org.springframework.web.servlet.handler.SimpleUrlHandlerMapping&amp;quot;&amp;gt;
            &amp;lt;property name=&amp;quot;mappings&amp;quot;&amp;gt;
                 &amp;lt;props&amp;gt;
                       &amp;lt;prop key=&amp;quot;sample.do&amp;quot;&amp;gt;sampleMultiActionController&amp;lt;/prop&amp;gt;
                 &amp;lt;/props&amp;gt;
            &amp;lt;/property&amp;gt;
     &amp;lt;/bean&amp;gt;
     &amp;lt;bean id=&amp;quot;viewResolver&amp;quot; class=&amp;quot;org.springframework.web.servlet.view.InternalResourceViewResolver&amp;quot;&amp;gt;
            &amp;lt;property name=&amp;quot;viewClass&amp;quot;&amp;gt;
                 &amp;lt;value&amp;gt;org.springframework.web.servlet.view.InternalResourceView&amp;lt;/value&amp;gt;
            &amp;lt;/property&amp;gt;
            &amp;lt;property name=&amp;quot;prefix&amp;quot;&amp;gt;
                 &amp;lt;value&amp;gt;/WEB-INF/jsp/&amp;lt;/value&amp;gt;
            &amp;lt;/property&amp;gt;
            &amp;lt;property name=&amp;quot;suffix&amp;quot;&amp;gt;
                 &amp;lt;value&amp;gt;.jsp&amp;lt;/value&amp;gt;
            &amp;lt;/property&amp;gt;
     &amp;lt;/bean&amp;gt;


     &amp;lt;bean id=&amp;quot;sampleMultiActionController&amp;quot; class=&amp;quot;com.test.SampleMultiActionController&amp;quot;&amp;gt;
           &amp;lt;property name=&amp;quot;methodNameResolver&amp;quot;&amp;gt;
                 &amp;lt;ref bean=&amp;quot;paraMethodResolver&amp;quot;/&amp;gt;
           &amp;lt;/property&amp;gt;
     &amp;lt;!--viewName属性将依赖注入sampleMultiActionController类--&amp;gt;
           &amp;lt;property name=&amp;quot;viewName&amp;quot;&amp;gt;
                 &amp;lt;value&amp;gt;showme&amp;lt;/value&amp;gt;
           &amp;lt;/property&amp;gt;
     &amp;lt;/bean&amp;gt;

     &amp;lt;bean id=&amp;quot;paraMethodResolver&amp;quot; class=&amp;quot;org.springframework.web.servlet.mvc.multiaction.ParameterMethodNameResolver&amp;quot;&amp;gt;
           &amp;lt;property name=&amp;quot;paramName&amp;quot; value=&amp;quot;whichMethod&amp;quot;/&amp;gt;
     &amp;lt;/bean&amp;gt;
&amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;sample.do&lt;/code&gt;会被&lt;code&gt;SampleMultiActionController&lt;/code&gt;处理&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;viewName&lt;/code&gt;即&lt;code&gt;showme&lt;/code&gt;，被依赖注入传入Controller，通过&lt;code&gt;return new ModelAndView(getViewName(), ...)&lt;/code&gt;指定视图名称&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;viewResolver&lt;/code&gt;解析视图为&lt;code&gt;/WEB-INF/jsp/showme.jsp&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;methodNameResolver&lt;/code&gt;指定&lt;code&gt;ParameterMethodNameResolver&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;paraMethodResolver&lt;/code&gt;指定的参数名为&lt;code&gt;whichMethod&lt;/code&gt;，即能将&lt;code&gt;sample.do?whichMethod=insert&lt;/code&gt;这样的请求，映射到&lt;code&gt;insert()&lt;/code&gt;方法&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Spring DispatcherServlet相关知识点</title>
      <link>https://feng1st.github.io/post/2017-06-25-spring-dispatcher-servlet/</link>
      <pubDate>Sun, 25 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>https://feng1st.github.io/post/2017-06-25-spring-dispatcher-servlet/</guid>
      <description>

&lt;h2 id=&#34;dispatcherservlet作用&#34;&gt;DispatcherServlet作用&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;作为Spring MVC的集中访问点&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;通过HandlerMapping，将请求映射到Handler&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;返回一个HandlerExecutionChain，包含一个HandlerAdaptor和多个HandlerInterceptor&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;通过不同的HandlerAdaptor，支持不同的处理器&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;通过ViewResolver，支持到具体视图的解析&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;通过HandlerExceptionResolver，实现对异常的处理&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;每一部分都可以很方便的扩展&lt;/p&gt;

&lt;h2 id=&#34;dispatcherservlet流程&#34;&gt;DispatcherServlet流程&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;请求被DispatcherServlet截获&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;DispatcherServlet在候选handlerMappings里面，找到第一个能够处理request的handlerMapping&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;常见的handlerMapping：&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;RequestMappingHandlerMapping: 通过@RequestMapping注解的Controller的方法&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;内部有一个url到HandlerMethod的映射，通过这个映射来判断是否能处理&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;BeanNameUrlHandlerMapping: 通过web.xml配置的，从URL映射到bean。DispatcherServlet本身就是通过这种方式配置&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;handlerMapping构造一个HandlerExecutionChain&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;HandlerExecutionChain包含多个HandlerInterceptor和一个Handler&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;Handler是一个HandlerMethod，通过构造函数参数传入request&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Spring MVC默认会注入一个ConversionServiceExposingInterceptor，用来处理日期、时间等格式转换&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;用HandlerAdaptor封装chain里的handler&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;不同的handler接口不同，通过adaptor统一接口&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;DispatcherServlet有一个HandlerAdaptor的列表，采用第一个.supports(handler)的HandlerAdaptor&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;HandlerMethod对应的是RequestMappingHandlerAdaptor&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;依次执行各interceptor的preHandle，handlerAdaptor的handle和各interceptor的postHandle&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;HandlerAdaptor内部实例化一个ServletInvocableHandlerMethod&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;除了handler，还注入了HandlerMethodArgumentResolver列表、HandlerMethodReturnValueHandler列表以及DataBinderFactory&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;ServletInvocableHandlerMethod.invokeAndHandle()里&lt;br /&gt;

&lt;ol&gt;
&lt;li&gt;用argumentResolvers和dataBinderFactory转化参数&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;用argumentResolvers解析参数&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;用dataBinder转化参数，包括：形参是vo，url参数是vo的属性，就会通过它来构建一个vo的实参&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;调用用户在Controller的方法实现&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;用returnValueHandlers处理返回的结果&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;对于@ResponseBody类，直接转换成xml/json后写response，并返回null&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;使用HttpMessageConverter转换，比如StringHttpMessageConverter, MappingJackson2HttpMessageConverter&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;否则返回一个ModelAndView&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;DispatcherServlet如果拿到的是一个ModelAndView，会通过ViewREsolver找到对应的view，来渲染model&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;HandlerMethodArgumentResolver和HandlerMethodReturnValueHandler的例子：RequestResponseBodyMethodProcessor&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;用来处理&lt;code&gt;@RequestBody&lt;/code&gt;和&lt;code&gt;@ResponseBody&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;同时实现了HandlerMethodArgumentResolver和HandlerMethodReturnValueHandler接口&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;内部实现主要是读写Request和Response的Body，和使用HttpMessageConverter转换数据&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;filter和handlerinterceptor&#34;&gt;Filter和HandlerInterceptor&lt;/h2&gt;

&lt;p&gt;总体来说，两者是类似的。不同点：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Filter在web.xml定义，HandlerInterceptor在application context里定义&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;HandlerInterceptor接口分得更细&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Filter一般用来处理请求内容和视图内容，比如压缩和分块&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;HandlerInterceptor用来处理一般性面向切面逻辑，比如授权&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code&gt;public interface HandlerInterceptor {
    boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception;
    void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception;
    void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;参考资料&#34;&gt;参考资料&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://www.chawenti.com/articles/23718.html&#34;&gt;http://www.chawenti.com/articles/23718.html&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>微服务架构摘要</title>
      <link>https://feng1st.github.io/post/2017-06-23-microservices/</link>
      <pubDate>Fri, 23 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>https://feng1st.github.io/post/2017-06-23-microservices/</guid>
      <description>

&lt;p&gt;原文: &lt;a href=&#34;https://www.nginx.com/blog/introduction-to-microservices/&#34;&gt;https://www.nginx.com/blog/introduction-to-microservices/&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;单一框架有什么问题-微服务框架解决什么问题&#34;&gt;单一框架有什么问题 / 微服务框架解决什么问题？&lt;/h2&gt;

&lt;p&gt;单一框架经过常年发展，扩充之后：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;过于复杂，难于理解和修改。修改容易引入bug&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;启动变慢，降低调试和开发速度&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;无法持续部署，无法快速升级。一个组件需要升级，整个应用都需要重新部署。部署后，因为受影响部分不明，需要更多的人工测试&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;无法根据不同组件的需求进行伸缩扩展。比如，部分组件是CPU密集型，部分组件是内存密集型；部分组件压力小，单个实例可以应付，部分组件压力大，有部署多个实例的需求&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;可靠性，组件异常（比如内存泄露），导致整个应用异常&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;难于升级到新的技术和框架&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;微服务框架&#34;&gt;微服务框架&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;按功能划分，比如订单管理、客户端管理&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;每个微服务是一个单独的小应用&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;微服务对外暴露API，比如REST API&lt;br /&gt;
微服务之间可以通过暴露的API互相调用&lt;br /&gt;
微服务间还可以通过消息系统实现异步调用&lt;br /&gt;
外界一般不直接范围后端服务，而是通过API网关&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;微服务通常通过虚拟机或Docker部署&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;伸缩模型&#34;&gt;伸缩模型&lt;/h3&gt;

&lt;p&gt;x轴：水平复制，靠克隆伸缩。通过在负载均衡后部署多个实例，解决可用性和吞吐量的问题&lt;br /&gt;
y轴：功能解耦，靠拆分不同的事物伸缩。将单一应用通过功能/业务拆分成多个微服务&lt;br /&gt;
z轴：数据分区，靠拆分相似的事物伸缩&lt;/p&gt;

&lt;h3 id=&#34;微服务架构对数据库schema的影响&#34;&gt;微服务架构对数据库schema的影响&lt;/h3&gt;

&lt;p&gt;微服务架构要求每个微服务有自己单独的数据库schema&lt;br /&gt;
这是为了更彻底的解耦&lt;br /&gt;
但是不可避免的，多个微服务数据库间存在重复数据&lt;/p&gt;

&lt;h3 id=&#34;微服务架构和soa的异同&#34;&gt;微服务架构和SOA的异同&lt;/h3&gt;

&lt;p&gt;微服务架构和SOA在表现层有相似性：都是由多个服务构成&lt;br /&gt;
区别：&lt;br /&gt;
1. 微服务架构弃用了比较重的WS规范，采用轻量的协议，比如REST&lt;br /&gt;
2. 微服务架构弃用了ESB&lt;/p&gt;

&lt;h3 id=&#34;微服务的好处&#34;&gt;微服务的好处&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;将单一应用解构成多个服务，让每一个服务面临的复杂度降低，变得可管理、可控制、可维护&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;开发方面：可以选用自己的技术，可以使用较新的技术&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;部署方面：可以单独部署，更容易部署和测试&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;伸缩方面：更容易按需扩展多实例&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;微服务的问题&#34;&gt;微服务的问题&lt;/h3&gt;

&lt;p&gt;下面这些问题都不难解决，但是需要清楚存在这些问题&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;分布式架构下调用的开销，以及服务不可用的处理&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;数据库拆分后，分布式事务基本不采用，需要最终一致方案&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;测试更困难，可能需要启动服务本身和依赖服务（或者伪服务）&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;升级链，如果A依赖于B，需要先升级B，再升级A&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;部署，需要自动化工具&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;api网关&#34;&gt;API网关&lt;/h2&gt;

&lt;p&gt;门面模式 Facade&lt;/p&gt;

&lt;h3 id=&#34;客户端直接和后端服务通讯的问题-api网关要解决的问题&#34;&gt;客户端直接和后端服务通讯的问题 / API网关要解决的问题&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;客户端需要调用多个后端服务，走广域网，非常慢&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;客户端代码复杂&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;客户端需要支持后端服务API所使用的通讯协议&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;后端服务接口无法自由变更，服务之间无法合并和拆分&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;API网关除了解决上诉问题，还能：&lt;br /&gt;
1. 提供负载均衡、缓存、安全/权限控制，监控等&lt;br /&gt;
2. 为不同的客户端提供不同的接口&lt;/p&gt;

&lt;h3 id=&#34;挑战&#34;&gt;挑战：&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;需要额外实现和维护一个高可用的组件&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;可能成为开发瓶颈&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;实现api网关&#34;&gt;实现API网关&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;性能和高伸缩性&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;要支持异步、非阻塞通讯&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;技术选型：Netty, Spring Reactor, &amp;hellip;&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;使用反应式编程模型 Reactive Programming Model&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;需求：要支持直接转发单个请求；要支持调用多个请求，并聚合结果&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;需求：要支持彼此无关服务的并发调用；要支持有依赖关系服务的先后调用&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;不推荐使用回调实现异步（不直观、不容易理解、容易出错）&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;推荐使用Reactive&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;技术选型：CompletableFuture, RxJava&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;服务调用&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;同步调用：HTTP、Thrift&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;异步、消息机制：JMS、AMQP、Zeromq&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;API网关需要这些服务通讯，也应支持上诉通讯机制&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;服务发现&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;客户端发现：先请求服务地址列表，然后选择调用，负载均衡在客户端&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;服务端发现：注册总心选好后发给客户端，负载均衡在服务端&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;（这里的客户端指API网关）&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;处理部分失败&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;面对服务慢或者不可用的处理。核心是不能阻塞API网关&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;要根据服务是否重要，选择：&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;直接返回给客户端错误&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;返回空、默认值、缓存值、备份数据等&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;技术选型：Netflix Hystrix&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;进程间通讯-ipc&#34;&gt;进程间通讯 IPC&lt;/h2&gt;

&lt;h3 id=&#34;交互风格&#34;&gt;交互风格&lt;/h3&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;一对一&lt;/th&gt;
&lt;th&gt;一对多&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;同步&lt;/td&gt;
&lt;td&gt;Request/Response&lt;/td&gt;
&lt;td&gt;&amp;ndash;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;异步&lt;/td&gt;
&lt;td&gt;Notification&lt;/td&gt;
&lt;td&gt;Publish/Subscribe&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;Request/Async response&lt;/td&gt;
&lt;td&gt;Public/Async responses&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;ol&gt;
&lt;li&gt;Request/Response: 发送请求，等待响应。应有超时。线程阻塞&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Notification (单向请求): 发送请求，不期待有响应&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Request/Async response: 发送请求，不期待有即时响应。线程不阻塞&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Publish/Subscribe: 发布请求，多个消费者消费&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Publish/Async responses: 发布请求，等待多个响应。有超时&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;接口设计&#34;&gt;接口设计&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;基于消息：定义消息channel和消息类型&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;基于HTTP：定义URL、请求和响应格式&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;接口升级&#34;&gt;接口升级&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;向前兼容的小升级，比如增加/删除请求/响应字段：&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;缺失的字段采用默认值，忽略额外的字段&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;消息格式要支持，比如Protobuf，Json&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;大的升级：要使用版本区分，服务要在一段时间内同时支持新旧版本接口&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;处理部分失败&#34;&gt;处理部分失败&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;一定要有超时，不能无限阻塞&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;要限制客户端向同一服务的请求的数量，如果超限，直接失败&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;船舱隔离模式：&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;不同的调用分配到不同的线程池，不能因为慢速调用占满快速调用的线程池&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;电路熔断器模式：&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;连续超时：断开&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;等待一段时间：半开放&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;又有超时：再断开&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;或不再超时：恢复&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;要根据服务是否重要，选择：&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;直接返回给客户端错误&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;返回空、默认值、缓存值、备份数据等&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;ipc技术&#34;&gt;IPC技术&lt;/h3&gt;

&lt;h4 id=&#34;异步-基于消息的通讯&#34;&gt;异步、基于消息的通讯&lt;/h4&gt;

&lt;p&gt;关键字：消息头、消息体、频道、生产者、消费者、broker、点对点、发布/订阅、……&lt;br /&gt;
这里不展开&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;好处&lt;br /&gt;

&lt;ol&gt;
&lt;li&gt;客户端和服务解耦。客户端也不需要使用服务发现机制&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;消息缓存。支持消费者不实时在线&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;支持上面提到的所有交互风格&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;是显式IPC，不像有些RPC机制，尝试屏蔽是远程调用的事实。开发者有更好的意识和控制权&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;缺点&lt;br /&gt;

&lt;ol&gt;
&lt;li&gt;额外的操作复杂性，需要引入一个高可用的消息中间件（这个应该不是问题）&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;用来实现Request/Response比较复杂：&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;客户端的请求消息要带上响应的channel和唯一id&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;服务的响应消息要带上这个唯一id，发送到响应channel&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;客户端要用唯一id，从响应channel找到匹配响应消息&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;不难理解，但是确实比直接基于请求/响应的机制更复杂&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;同步-基于请求-响应的通讯&#34;&gt;同步、基于请求/响应的通讯&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;REST&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;核心是“资源”，基于HTTP请求类型和参数，实现资源的“增删改查”&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;REST定义也有不同的级别，从POST到同一URL，靠参数指定操作和对象，到靠HTTP请求类型指定操作，不同URL指定操作对象。不绝对&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;优势&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;基于HTTP，简单熟悉&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;构造请求简单，测试方便&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;天然支持请求/响应模式&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;防火墙友好&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;无中间层，系统结构简单&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;缺点&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;对逻辑上的单向请求（Notification），服务端也要发响应&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;服务端必须实时在线&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;客户端和服务端耦合。需要有服务发现机制&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;IDL：RAML和Swagger&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Thrift&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;支持请求/响应和通知（单向）&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;支持Json、二进制和压缩二进制。取舍是人工可读和占空间大小&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;支持HTTP和TCP。取舍是是否防火墙友好和效率&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;服务发现&#34;&gt;服务发现&lt;/h2&gt;

&lt;h3 id=&#34;为什么需要服务发现&#34;&gt;为什么需要服务发现&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;集群动态伸缩&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;基于Container的部署方式，IP和端口也是动态分配的&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;服务发现方式&#34;&gt;服务发现方式&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;客户端发现模式&lt;br /&gt;

&lt;ol&gt;
&lt;li&gt;服务端在启动时向注册中心注册、停止时取消注册、靠心跳刷新&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;客户端向注册中心获取服务端列表&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;客户端主动负载均衡，比如采用一致性hash&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;优点：直接&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;优点：可根据业务灵活选用负载均衡策略&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;缺点：客户端和注册中心耦合&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;实现技巧：客户端和服务端均在注册中心注册，便于服务端变更时，注册中心主动推送。参考dubbo&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;服务端发现模式&lt;br /&gt;

&lt;ol&gt;
&lt;li&gt;客户端请求发给负载均衡服务器&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;负载均衡服务器负责和注册中心通讯&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;优点：客户端和服务发现逻辑解耦&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;缺点：需要高可用的负载均衡服务器&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;注册中心&#34;&gt;注册中心&lt;/h3&gt;

&lt;p&gt;参考：Zookeeper&lt;br /&gt;
注册方式：&lt;br /&gt;
1. 自注册：优点：直接；缺点：服务和注册中心耦合&lt;br /&gt;
2. 第三方组件注册：优点：解耦；缺点：额外高可用组件&lt;/p&gt;

&lt;h2 id=&#34;事件驱动数据模型&#34;&gt;事件驱动数据模型&lt;/h2&gt;

&lt;p&gt;数据随着微服务拆分，带来下面的挑战：&lt;br /&gt;
1. 跨服务事务的一致性&lt;br /&gt;
    - 2PC 两阶段提交在此情况下不可用，CAP要优先满足A，或者BASE&lt;br /&gt;
2. 怎样从多个服务请求数据&lt;/p&gt;

&lt;h3 id=&#34;事件驱动架构&#34;&gt;事件驱动架构&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;将跨服务的事务划分为多步&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;每一步，一个微服务更新业务对象（本地事务），同时产生一个事件以激发下一步&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;事件通过消息系统传递&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;例子：创建订单&lt;br /&gt;
1. 订单服务创建订单，状态为NEW，然后发布订单创建消息到消息系统&lt;br /&gt;
2. 客户服务收到订单创建消息，预留订单费用，发布预留订单费用消息&lt;br /&gt;
    - 预留费用至少涉及到两个表，是一个本地事务。要能想到&lt;br /&gt;
    - 1. &lt;code&gt;customer.credit_limit - sum(reserved_credit.amount) &amp;gt;= order_total&lt;/code&gt;&lt;br /&gt;
    - 2. &lt;code&gt;insert into reserved_credit (... amount) values (... order_total)&lt;/code&gt;&lt;br /&gt;
    - 如果要保证事务发送成功，事务里还要包括第3个表，事务表（见下）&lt;br /&gt;
    - 
&lt;figure &gt;
    &lt;a href=&#34;Richardson-microservices-part5-credit-check-2-e1449727579423.png&#34;&gt;
        &lt;img src=&#34;Richardson-microservices-part5-credit-check-2-e1449727579423.png&#34; /&gt;
    &lt;/a&gt;
    
&lt;/figure&gt;
&lt;br /&gt;
3. 订单服务收到预留订单费用消息，将订单状态更新为OPEN&lt;/p&gt;

&lt;p&gt;因为服务统一向消息系统发事务，可以有一个视图服务，订阅这些事务，更新事务，实现跨服务查询&lt;/p&gt;

&lt;h3 id=&#34;原子性&#34;&gt;原子性&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;使用本地事务发布事件&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;将操作业务对象和插入事件表放到一个事务里面&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;
&lt;figure &gt;
    &lt;a href=&#34;Richardson-microservices-part5-local-transaction-e1449727484579.png&#34;&gt;
        &lt;img src=&#34;Richardson-microservices-part5-local-transaction-e1449727484579.png&#34; /&gt;
    &lt;/a&gt;
    
&lt;/figure&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;事件发布者轮询事件表，确保事件发送成功 at least once&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;挖掘数据库事务日志&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;实现较复杂&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;使用事件源&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;保存的不是结果，而是操作步骤&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;逻辑较复杂&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;部署&#34;&gt;部署&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;每微服务一虚拟机&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;隔离性高&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;开销大&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;每微服务一容器&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;隔离性低&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;开销小&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;实现：Docker&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;重构单一架构到微服务架构&#34;&gt;重构单一架构到微服务架构&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;新功能直接使用微服务实现&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;前端路由请求到旧单一应用和新微服务&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;新微服务使用“胶水代码”访问旧单一应用&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;访问旧单一应用的数据&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;远程调用旧单一应用接口&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;直接访问旧单一应用数据库&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;维护独立数据，和旧数据库同步&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;拆分前后端&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;最容易拆的是表现层和逻辑层。逻辑层和数据层稍难&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;表现层拆出来后便于独立开发和A/B测试&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;拆模块&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;优先级&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;先拆变化频繁的，便于加速后继开发&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;再拆资源要求不一样的，便于分开部署和伸缩&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;再拆和其它模块交互较粗的，比如通过消息系统交互的&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;步骤&lt;br /&gt;

&lt;ol&gt;
&lt;li&gt;模块和剩余部分改成IPC通讯&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;将模块独立成微服务&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>工具推荐：PlantUML，文本转UML图工具</title>
      <link>https://feng1st.github.io/post/2017-06-22-plantuml/</link>
      <pubDate>Thu, 22 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>https://feng1st.github.io/post/2017-06-22-plantuml/</guid>
      <description>

&lt;p&gt;官网：&lt;a href=&#34;http://plantuml.com/&#34;&gt;http://plantuml.com/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;为什么要用文本生成UML，而不直接画UML？&lt;br /&gt;
这就好像问为什么要用markdown，而不直接使用.odt或者.docx格式。答案一样：&lt;br /&gt;
这属于强迫症，得治。&lt;/p&gt;

&lt;h2 id=&#34;安装&#34;&gt;安装&lt;/h2&gt;

&lt;p&gt;如果使用ubuntu，直接：&lt;br /&gt;
&lt;code&gt;sudo apt-get install graphviz plantuml&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;其它平台或者安装方法请参考官网&lt;/p&gt;

&lt;h2 id=&#34;使用&#34;&gt;使用&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;plantuml src.txt&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;如果是下载的jar：&lt;br /&gt;
&lt;code&gt;java -jar plantuml.jar src.txt&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;会在当前目录下生成&lt;code&gt;src.png&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;示例&#34;&gt;示例&lt;/h2&gt;

&lt;p&gt;输入：&lt;br /&gt;
&lt;code&gt;jetty-handler.pu&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@startuml
interface Handler {
  +handle(request)
}
abstract class AbstractHandler
class HandlerWrapper
class ServletHandler
class HandlerContainer
class Server
class SessionHandler {
  +SessionManager
}
class SecurityHandler {
  +SecurityConstraint[]
}
class ContextHandler {
  +contextPath
  +resourceBase
  +classLoader
}
class ContextHandlerContainer {
  -contexts: PathMap
}
class WebAppContext {
  +descriptor
}

Handler &amp;lt;|.. AbstractHandler
Handler &amp;quot;1&amp;quot; --o HandlerWrapper
Handler &amp;quot;*&amp;quot; --o HandlerContainer
AbstractHandler &amp;lt;|-- HandlerWrapper
AbstractHandler &amp;lt;|-- ServletHandler
AbstractHandler &amp;lt;|-- HandlerContainer
AbstractHandler ..&amp;gt; Server
HandlerWrapper &amp;lt;|-- Server
HandlerWrapper &amp;lt;|-- SessionHandler
HandlerWrapper &amp;lt;|-- SecurityHandler
HandlerWrapper &amp;lt;|-- ContextHandler
ServletHandler &amp;lt;.. WebAppContext
HandlerContainer &amp;lt;|-- ContextHandlerContainer
SessionHandler &amp;lt;.. WebAppContext
SecurityHandler &amp;lt;.. WebAppContext
ContextHandler &amp;lt;. ContextHandlerContainer
ContextHandler &amp;lt;|-- WebAppContext
@enduml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出：&lt;br /&gt;
&lt;code&gt;jetty-handler.png&lt;/code&gt;&lt;br /&gt;

&lt;figure &gt;
    &lt;a href=&#34;jetty-handler.png&#34;&gt;
        &lt;img src=&#34;jetty-handler.png&#34; /&gt;
    &lt;/a&gt;
    
&lt;/figure&gt;
&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>微服务架构笔记</title>
      <link>https://feng1st.github.io/post/2017-06-19-microservices/</link>
      <pubDate>Mon, 19 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>https://feng1st.github.io/post/2017-06-19-microservices/</guid>
      <description>

&lt;p&gt;原文：&lt;a href=&#34;http://blog.csdn.net/mindfloating/article/details/24583369&#34;&gt;http://blog.csdn.net/mindfloating/article/details/24583369&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;什么是微服务架构&#34;&gt;什么是微服务架构&lt;/h2&gt;

&lt;p&gt;采用一组服务的方式来构建一个应用；&lt;br /&gt;
服务独立部署在不同的进程；&lt;br /&gt;
服务之间通过轻量级的机制来通讯，比如RPC、HTTP；&lt;br /&gt;
服务可独立扩展伸缩；&lt;br /&gt;
每个服务定义了明确的边界；&lt;br /&gt;
不同服务可以采用不同的技术实现，由独立的团队维护。&lt;/p&gt;

&lt;h2 id=&#34;微服务架构的特征&#34;&gt;微服务架构的特征&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;通过服务实现组件化&lt;br /&gt;
和传统方式，或者说单一架构(Monolithic Architecture)类比：&lt;br /&gt;
传统方式实现组件化：通过库(library)；和应用运行在一个进程里；组件升级，应用需要重新部署&lt;br /&gt;
服务方式实现组件化：通过服务；部署在不同的进程；可以单独升级&lt;br /&gt;
因为服务是跨进程的，所以在设计阶段就必须定义好明确的边界&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;按业务能力来划分服务和组织团队&lt;br /&gt;
传统方式按技术分层：前端、后端、数据库&lt;br /&gt;
微服务架构：按业务划分，全栈工程师或全栈团队&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;服务即产品&lt;br /&gt;
团队即负责开发，也负责维护&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;智能终端和哑管道&lt;br /&gt;
抛弃过于复杂的ESB，服务自己处理自己的业务逻辑&lt;br /&gt;
服务间通讯尽量轻量，不添加额外的规则&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;去中心统一化&lt;br /&gt;
各服务可以选用自己的技术实现&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;自动化基础设施服务&lt;br /&gt;
必须要存在自动化的服务治理平台，才能降低开发、调试、测试、部署、监控、维护的复杂度&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Design for failure&lt;br /&gt;
服务消费者要优雅的处理远程调用带来的错误&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;进化设计&lt;br /&gt;
发送方要最小化，只发送必要的信息&lt;br /&gt;
接收方要最大化，要最大化容错，要允许传入不认识的参数&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;服务的划分&#34;&gt;服务的划分&lt;/h2&gt;

&lt;p&gt;参考点之一：如果功能A发生改变，功能B也要随之改变，一般它们应划在同一个服务里&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>面向服务架构笔记</title>
      <link>https://feng1st.github.io/post/2017-06-18-soa/</link>
      <pubDate>Sun, 18 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>https://feng1st.github.io/post/2017-06-18-soa/</guid>
      <description>

&lt;h2 id=&#34;分布式应用架构的演化&#34;&gt;分布式应用架构的演化&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;DOA 分布式对象架构&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;主要特征：&lt;br /&gt;

&lt;ol&gt;
&lt;li&gt;对象是可以在服务器/容器间自由“移动”的&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;被调用的对象究竟是本地，还是远程，对调用者来说是透明的&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;例子：EJB&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;问题：复杂和性能&lt;br /&gt;

&lt;ol&gt;
&lt;li&gt;远程调用有更多可能出错的环节&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;分布式事务需要两阶段提交&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;远程通讯额外的开销&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;SOA 面向服务架构&lt;br /&gt;

&lt;ol&gt;
&lt;li&gt;服务是可“移动”的，但是远没有DOA那样不可控&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;当调用其它服务时，调用者知道这是一个远程调用。对复杂度和性能有更好的把控&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;企业服务总线-esb&#34;&gt;企业服务总线 ESB&lt;/h2&gt;

&lt;p&gt;ESB是SOA的核心组件，其主要特点：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;服务访问单点：服务提供者和服务消费者都只需要知道ESB的存在。服务发生变化，只需要修改ESB的配置&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;事物管理器：分布式事物管理器放在这个地方很自然&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;安全管理器：访问权限、授权管理&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;服务代理：统一服务接口和数据格式的一个Adaptor和Proxy&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;对外部的网关&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;但是ESB也有一定的缺点：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;单点故障：ESB发生故障，整个系统将不可用&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;单点性能：分布式系统中，承担ESB角色的单点是必须的，比如服务注册和发现。&lt;br /&gt;
但是，究竟要承担哪些具体的工作，是一个需要考虑的点。&lt;br /&gt;
比如，如果服务之间的通讯都要经过ESB，ESB会不会成为整个系统的性能瓶颈，会不会增大故障的概率&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;同上，增加了服务间访问的间接性，降低了性能&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;soa简介&#34;&gt;SOA简介&lt;/h2&gt;

&lt;p&gt;SOA的目标是实现灵活可变的分布式IT系统，这需要：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;标准化：协议标准化，实现互访问&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;复用：服务可复用&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;松耦合可编排：分布式对象技术分离了连接逻辑，消息中间件实现了连接逻辑的异步，SOA架构实现了业务逻辑的解耦&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;soa治理&#34;&gt;SOA治理&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;服务注册与发现&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;可靠性&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;安全性&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;负载均衡&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;监控与日志&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;服务限流和容错&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;完整soa模型&#34;&gt;完整SOA模型&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;基础设施服务&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;企业服务总线&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;关键服务组件&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;开发工具&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;管理工具&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;参考资料&#34;&gt;参考资料&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://tutorials.jenkov.com/soa/&#34;&gt;http://tutorials.jenkov.com/soa/&lt;/a&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.vsharing.com/fengjicheng/A1059842.html&#34;&gt;http://blog.vsharing.com/fengjicheng/A1059842.html&lt;/a&gt;&lt;br /&gt;
-&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>高并发解决思路</title>
      <link>https://feng1st.github.io/post/2017-06-17-high-concurrency/</link>
      <pubDate>Sat, 17 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>https://feng1st.github.io/post/2017-06-17-high-concurrency/</guid>
      <description>

&lt;p&gt;解决高并发，无非两个方向：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;分而治之：分流&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;优化单个服务器处理能力&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;客户端&#34;&gt;客户端&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;尽量使用缓存&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;尽量本地处理&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;尽量减少不必要的访问&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;分流&#34;&gt;分流&lt;/h2&gt;

&lt;p&gt;LVS、Nginx、Varnish放到一块说&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;负载均衡&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;业务拆分&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;静态内容直接返回，包括使用CDN&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;缓存（动态内容缓存、页面片段缓存）&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;优化单个服务器处理程序&#34;&gt;优化单个服务器处理程序&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;缓存：缓存永远是最重要的&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;异步：能异步就异步&lt;br /&gt;
如果有多个异步调用没有依赖关系，可以并行调用，然后在最后一起等结果&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;多线程：&lt;br /&gt;
如果是CPU吃重的应用，线程数过高不能解决问题&lt;br /&gt;
I/O吃重要分成两种：1种是因为传输数据量过大，导致I/O重，这种线程数高不解决问题&lt;br /&gt;
另一种是传输数据不大，但是等待远端处理的时间很长，这种可以提升线程数，并发处理后面的任务&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;预处理：预先算出局部结果，要获取整体结果时，只需要基于局部结果计算。比如月报表可以基于天报表&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;还有一种预处理，是和缓存结合的预处理&lt;br /&gt;
不是等到缓存失效时，再穿透后端。而是缓存快要失效时，就起线程向后端请求数据更新缓存。在线程处理期间，缓存里的数据依然是有效的。线程处理完毕，缓存里的数据已更新&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;优化SQL，正确使用索引&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;尽量不要使用分布式事务&lt;br /&gt;
2阶段提交不是万能药&lt;br /&gt;

&lt;ol&gt;
&lt;li&gt;各节点进入事务&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;各节点事务执行完毕，prepare（意味着，接下来出了问题，比如重启，事务也能生效）&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;各节点commit&lt;br /&gt;
假设最后一个节点，commit前离线了，并且永远不再上线，事务状态依然是错误的&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;应用算法优化&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;优化数据层&#34;&gt;优化数据层&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;合理选用数据库（OLTP、OLAP）和引擎（InnoDB、MyISAM）&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;合理设置索引&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;使用集群，读写分离&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;合理分表分库&lt;br /&gt;
分表我看来最大的好处是，是索引变小，能够加载到内存&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Tomcat笔记</title>
      <link>https://feng1st.github.io/post/2017-06-14-tomcat/</link>
      <pubDate>Wed, 14 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>https://feng1st.github.io/post/2017-06-14-tomcat/</guid>
      <description>

&lt;h2 id=&#34;架构&#34;&gt;架构&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Server: 整个容器&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Service: 关联Container和Connector的中间人，包含一个Container和多个Connector&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Connector: 负责和客户端的网络通讯，接受/建立连接，接收请求，返回响应&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;维持一个一定大小的线程池，创建多个Processor，当请求来的时候，将socket和processor绑定，然后运行&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Request, Response是在这里创建的，然后传递给Container&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;低版本Tomcat可以修改配置文件server.xml，为Connector使用&lt;code&gt;protocol=&amp;quot;org.apache.coyote.http11.Http11NioProtocol&amp;quot;&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Container: 所有容器的父接口，下面4个重要的实现类/子接口&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;Engine, Host, Context, Wrapper&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;4个之间不是并列关系，是父子包含关系&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Engine: 是一个Service的根容器，处理请求的总管道 Pipeline&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Host: Engine的子容器，负责处理访问某特定host的请求。还实现了Deployer接口，实现应用程序的展开、部署、启动&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Context: Host的子容器，负责处理访问某特定路径 path 的请求。也是我们的单个应用程序的单位&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Wrapper: Context的子容器，负责调用Filter和Servlet&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;LifeCycle: 生命周期管理，包括父容器启动时，分别启动子容器。父容器结束前，分别结束子容器&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Pipeline: Valve的容器，请求传递的责任链。Pipeline内的Valve依次调用，最后一个Valve调用下一层级的Pipeline&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;EngineValve1 -&amp;gt; EngineValve2 -&amp;gt; ... -&amp;gt; StandardEngineValve -&amp;gt; HostPipeline&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Valve: Pipeline的切入点&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;StandardEngineValve: Engine pipeline上最后一个valve，调用Host&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;StandardHostValve: Host pipeline上最后一个valve，调用Context&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;StandardContextValve: Context pipeline上最后一个valve，调用Wrapper&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;StandardWrapperValve: Wrapper pipeline上最后一个valve，负责生成并调用filterChain，最后调用servlet&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;处理请求&#34;&gt;处理请求&lt;/h2&gt;

&lt;p&gt;时序图&lt;br /&gt;

&lt;figure &gt;
    &lt;a href=&#34;request-process.png&#34;&gt;
        &lt;img src=&#34;request-process.png&#34; /&gt;
    &lt;/a&gt;
    
&lt;/figure&gt;
&lt;/p&gt;

&lt;h2 id=&#34;classloader&#34;&gt;ClassLoader&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;是典型的双亲委托模式 Parents Delegation Model&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;要求：&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;common目录下的类被Tomcat和应用使用&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;server目录下的类只被Tomcat使用&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;shared目录下的类可以被所有应用使用&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;应用目录下的类只可以被本应用使用&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;实现（ClassLoader层级关系）：&lt;br /&gt;
&lt;div class=&#34;mermaid&#34;&gt;
graph RL
    commonLoader--&gt;systemLoader
    catalinaLoader--&gt;commonLoader
    sharedLoader--&gt;commonLoader
    webAppLoader1--&gt;sharedLoader
    webAppLoader2--&gt;sharedLoader
    
&lt;/div&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Jetty笔记</title>
      <link>https://feng1st.github.io/post/2017-06-12-jetty/</link>
      <pubDate>Mon, 12 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>https://feng1st.github.io/post/2017-06-12-jetty/</guid>
      <description>

&lt;h2 id=&#34;核心组成部分&#34;&gt;核心组成部分&lt;/h2&gt;

&lt;div class=&#34;mermaid&#34;&gt;
graph LR
L(LifeCycle)
C(Connector)---S(Server)
H(Handler)---S
S---P(ThreadPool)

&lt;/div&gt;


&lt;h2 id=&#34;lifecycle&#34;&gt;LifeCycle&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;start();
stop();
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;管理server对象的生命周期&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Connector, Handler, ThreadPool都实现了LifeCycle接口&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;LifeCycle的监听使用了观察者模式&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;connector&#34;&gt;Connector&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;接受TCP连接&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;用配置的ConnectionFactory创建Connection，和连接绑定&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;可配置多个ConnectionFactory，链式调用，分别完成各自一层的工作，比如：&lt;br /&gt;

&lt;ol&gt;
&lt;li&gt;ProxyConnectionFactory：处理Proxy协议&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;SslConnectionFactory：SSL加密解密&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;HttpConnectionFactory：处理实际的HTTP请求&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;handler&#34;&gt;Handler&lt;/h2&gt;


&lt;figure &gt;
    &lt;a href=&#34;basic-architecture-handlers.png&#34;&gt;
        &lt;img src=&#34;basic-architecture-handlers.png&#34; /&gt;
    &lt;/a&gt;
    
&lt;/figure&gt;


&lt;ol&gt;
&lt;li&gt;Jetty用一个Handler模型就完成了请求在整个server的不同层级的处理，这个是Jetty保持轻量和容易扩展的原因，这里说一下它的设计模式。&lt;br /&gt;

&lt;ol&gt;
&lt;li&gt;HandlerWrapper：形式上是装饰者模式，使用方式上是责任链模式&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;装饰者模式 Decorator：实现对所包装对象在本层级的拦截。比如，SessionHandler处理Session，SecurityHandler处理安全验证后，再调用被包装Handler的handle()&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;责任链模式 Chain of Responsibility：已经提到过，调用被包装Handler的handle()，实现责任链&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;HandlerContainer：组合模式 Composite，树形结构&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;模板方法 Template Method：比如ScopedHandler.doScope()，更清晰的向使用者阐述类的职责&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;门面模式 Facade：Context相关类，限制暴露方法的范围&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;Handler风格分类：&lt;br /&gt;

&lt;ol&gt;
&lt;li&gt;协调型，路由请求到其它Handler（HandlerCollection, ContextHandlerCollection）&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;过滤型，拦截修改到其它Handler的请求（HandlerWrapper, SessionHandler, ContextHandler）&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;处理型，处理请求，生成响应（StaticHandler, ServletHandler）&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;调用方式：&lt;br /&gt;

&lt;figure &gt;
    &lt;a href=&#34;basic-architecture-nested-handlers.png&#34;&gt;
        &lt;img src=&#34;basic-architecture-nested-handlers.png&#34; /&gt;
    &lt;/a&gt;
    
&lt;/figure&gt;
&lt;br /&gt;

&lt;ol&gt;
&lt;li&gt;顺序调用，代表：HandlerCollection&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;嵌套调用，代表：HandlerWrapper&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;servlethandler&#34;&gt;ServletHandler&lt;/h2&gt;


&lt;figure &gt;
    &lt;a href=&#34;basic-architecture-servlet-handler.png&#34;&gt;
        &lt;img src=&#34;basic-architecture-servlet-handler.png&#34; /&gt;
    &lt;/a&gt;
    
&lt;/figure&gt;


&lt;ol&gt;
&lt;li&gt;ServletHandler持有多个FilterHolder和ServletHolder&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;作为Servlet容器，调用时先调用所有的Filter，再调用Servlet&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;context&#34;&gt;Context&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;简单的说，分组环境变量&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;几个时序图&#34;&gt;几个时序图&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Jetty启动&lt;br /&gt;

&lt;figure &gt;
    &lt;a href=&#34;image011.jpg&#34;&gt;
        &lt;img src=&#34;image011.jpg&#34; /&gt;
    &lt;/a&gt;
    
&lt;/figure&gt;
&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;先启动线程池，再启动Handler，最后Connector。前者是处理后者的前提。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Jetty建立连接&lt;br /&gt;

&lt;figure &gt;
    &lt;a href=&#34;image013.jpg&#34;&gt;
        &lt;img src=&#34;image013.jpg&#34; /&gt;
    &lt;/a&gt;
    
&lt;/figure&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Jetty处理连接&lt;br /&gt;

&lt;figure &gt;
    &lt;a href=&#34;image015.jpg&#34;&gt;
        &lt;img src=&#34;image015.jpg&#34; /&gt;
    &lt;/a&gt;
    
&lt;/figure&gt;
&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;注意Request/Response是在什么地方创建的&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;引用来源&#34;&gt;引用来源&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://www.eclipse.org/jetty/documentation/current/architecture.html&#34;&gt;http://www.eclipse.org/jetty/documentation/current/architecture.html&lt;/a&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.ibm.com/developerworks/cn/java/j-lo-jetty/&#34;&gt;https://www.ibm.com/developerworks/cn/java/j-lo-jetty/&lt;/a&gt;&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Servlet笔记</title>
      <link>https://feng1st.github.io/post/2017-06-11-servlet/</link>
      <pubDate>Sun, 11 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>https://feng1st.github.io/post/2017-06-11-servlet/</guid>
      <description>

&lt;p&gt;教程：&lt;br /&gt;
&lt;a href=&#34;http://tutorials.jenkov.com/java-servlets/&#34;&gt;http://tutorials.jenkov.com/java-servlets/&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;一些思考点&#34;&gt;一些思考点&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Servlet的生命周期是怎样被&lt;strong&gt;容器&lt;/strong&gt;管理的？&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Session是怎样被管理和传递的？&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;分布式环境下Session是怎样被管理的？&lt;br /&gt;

&lt;ol&gt;
&lt;li&gt;统一Session中心&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;或者Session Sticky&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;ServletContext是怎样被管理和传递的，典型用途是什么？&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;request.getSession().getServletContext();&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;为什么要使用RequestDispatcher，而不是，比如直接调用其它Servlet？&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Filter和Servlet有什么异同？&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;接口&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;Servlet: init(), service(), destroy()&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;HttpServlet: doGet(), doPost(), &amp;hellip;&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Filter: init(), doFilter(), destroy()&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;设计&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;Servlet: 面向事务&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Filter: 面向切面&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Filter和Servlet分属不同两个类，为什么filterChain.doFilter()能把请求传递给Servlet&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;filterChain最后一个默认的filter调用servlet&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;怎样用Filter实现GZip，这个实现和AOP有什么区别？&lt;br /&gt;

&lt;ol&gt;
&lt;li&gt;判断请求头Accept-Encoding是否包括gzip&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;增加响应头Content-Encoding&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;用带GZip的Response封装原Response，并向后传递&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;Session和ServletContext是线程安全的吗？&lt;br /&gt;
不安全&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Java NIO摘要</title>
      <link>https://feng1st.github.io/post/2017-06-10-java-nio/</link>
      <pubDate>Sat, 10 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>https://feng1st.github.io/post/2017-06-10-java-nio/</guid>
      <description>

&lt;p&gt;比较经典和精简的教程，先直接发链接：&lt;br /&gt;
&lt;a href=&#34;http://tutorials.jenkov.com/java-nio/&#34;&gt;http://tutorials.jenkov.com/java-nio/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;NIO的实现不复杂，但是其体现了一个统一、可伸缩的面向数据/信息流的设计思想&lt;br /&gt;
例如，换用消息队列，就可以扩展到分布式系统里去&lt;/p&gt;

&lt;h2 id=&#34;一些思考点&#34;&gt;一些思考点&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Channel和Stream有什么不同？&lt;br /&gt;

&lt;ol&gt;
&lt;li&gt;Channel双向，Stream一般单向&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Channel支持异步&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Channel搭配Buffer使用&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;ServerSocketChannel和SocketChannel有什么不同？&lt;br /&gt;

&lt;ol&gt;
&lt;li&gt;SocketChannel用于单个连接&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;ServerSocketChannel用于监听端口，对每一个接受的连接创建一个SocketChannel&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;FileChannel.transferTo(&amp;hellip;, SocketChannel)有什么需要注意的？&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;SocketChannel非阻塞且发送缓冲已满，可能只传输部分&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;SocketChannel的blocking和non-blocking模式有什么不同？&lt;br /&gt;

&lt;ol&gt;
&lt;li&gt;相对于阻塞，connect()直接返回，需要后继调用finishConnect()判断成功&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;write()/read()可能未实际读写就返回&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;ServerSocketChannel的blocking和non-blocking模式有什么不同？&lt;br /&gt;

&lt;ol&gt;
&lt;li&gt;相对于阻塞，accept()直接返回，如没有接受连接，返回null&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;write()/read()可能未实际读写就返回&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;Blocking模式Socket有什么问题？&lt;br /&gt;

&lt;ol&gt;
&lt;li&gt;一般会用一个线程处理一个连接，所以支撑的连接数非常有限&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;如果使用连接池复用活动连接，一些慢速或者非活动连接可能会占满连接池&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;Non-blocking模式Socket有哪些挑战？&lt;br /&gt;

&lt;ol&gt;
&lt;li&gt;读到的字节流拆分Message：文章提到了TLV，但最好用长度+内容+校验构成&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;长度：TLV中的L&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;内容：类型是包含在这里面的，比如protobuf协议&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;校验：用于验证数据错误，或者网络错误，通知重传&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;读写的Message要有长度限制，否则一个伪造的字节流就能把服务器撑垮&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;一般会定义一种特定Message，专门用来拆分大的其它Message，长度和校验部分机制不变，内容部分构成如下&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;总段数&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;本段序号&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;本段内容&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;发送方不能把所有的Channel都注册到Selector，因为Selector.select()时，可能大部分Channel都可写，全部返回，性能低下&lt;br /&gt;

&lt;ol&gt;
&lt;li&gt;当本Channel对应缓冲区有待发送数据时，才注册到Selector&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;当缓冲区数据发送完毕时，从Selector取消注册&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;Selector有哪两种底层实现？&lt;br /&gt;

&lt;ol&gt;
&lt;li&gt;Reactor：轮询Channel对应底层IO句柄。当连接数过多时，性能低下。这个可以算是多路复用，因为select()时还是有等待的过程&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;e-poll：注册回调函数，只有当有对应事件发生时，才通知Selector。这个算是真正的异步。Linux直接支持&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;阻塞/非阻塞，同步/异步&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;阻塞：调用io函数会一直等待，比如System.in.read()&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;非阻塞：调用io函数，只读写可以读写的部分，然后立刻返回，比如NIO&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;同步：用等待或者轮询的方式拿到结果，比如NIO&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;异步：当时不用拿到结果，事后再获取结果，或者等到结果通知。使用Future或者Callback，比如AsynchronousFileChannel&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;额外提一下Node.js的线程模型&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;
&lt;figure &gt;
    &lt;a href=&#34;733213-20160306210005159-1364173213.png&#34;&gt;
        &lt;img src=&#34;733213-20160306210005159-1364173213.png&#34; /&gt;
    &lt;/a&gt;
    
&lt;/figure&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>HTTP协议摘要</title>
      <link>https://feng1st.github.io/post/2017-06-09-http-protocol/</link>
      <pubDate>Fri, 09 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>https://feng1st.github.io/post/2017-06-09-http-protocol/</guid>
      <description>

&lt;h2 id=&#34;http协议概述&#34;&gt;HTTP协议概述&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;基于服务器/客户端，请求/响应&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;无连接（1.1开始支持长连接Web Socket）&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;无状态（需要依赖会话维持状态）&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;应用层协议，基于TCP&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;url&#34;&gt;URL&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;http://host:port/res_uri.html?param=...&lt;/code&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;协议：如http, https, ftp等&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;用户名/密码：部分协议例如ftp支持用户名密码&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;域名和端口：要访问服务器的域名和端口，不同协议有自己的默认端口&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;访问资源：要访问资源的路径和参数&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;请求&#34;&gt;请求&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;GET /index.html HTTP/1.0&amp;lt;CRLF&amp;gt;
Host:www.sina.com.cn&amp;lt;CRLF&amp;gt;
Accept-Encoding:gzip, deflate&amp;lt;CRLF&amp;gt;
User-Agent:Mozilla/4.0(compatible;MSIE6.0;Windows NT 5.0)&amp;lt;CRLF&amp;gt;
Connection:Keep-Alive&amp;lt;CRLF&amp;gt;
&amp;lt;CRLF&amp;gt;
{Optional Content Body}
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;起始行：Method Request-URI HTTP-Version&lt;CRLF&gt;&lt;br /&gt;

&lt;ol&gt;
&lt;li&gt;请求方法&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;GET 请求Request-URI所标识的资源&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;POST 在资源后附加新的数据&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;HEAD 请求获取资源的响应消息报头&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;PUT 请求服务器存储一个资源&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;DELETE 请求删除资源&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;TRACE 请求服务器回送收到的请求信息，用于诊断测试&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;CONNECT 保留字&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;OPTIONS 请求查询服务器性能&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;消息报头：（见后）&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;消息主体：可选，对POST请求，消息主体为POST的数据&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;响应&#34;&gt;响应&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;HTTP/1.1 200 OK&amp;lt;CRLF&amp;gt;
Content-Length:123&amp;lt;CRLF&amp;gt;
Content-Type:text/html;charset=utf-8&amp;lt;CRLF&amp;gt;
...&amp;lt;CRLF&amp;gt;
&amp;lt;CRLF&amp;gt;
{Optional Content Body}
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;起始行：HTTP-Version Status-Code Reason-Phrase&lt;CRLF&gt;&lt;br /&gt;

&lt;ol&gt;
&lt;li&gt;状态码&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;1xx：指示信息&amp;ndash;消息已接收，继续处理&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;2xx：成功&amp;ndash;消息已被成功接收、理解、接受&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;200 OK&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;3xx：重定向&amp;ndash;要完成请求必须进行进一步的操作&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;4xx：客户端错误&amp;ndash;请求有语法错误或者请求无法实现&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;400 Bad Request&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;401 Unauthorized&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;403 Forbidden&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;404 Not Found&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;5xx：服务端错误&amp;ndash;服务端无法实现请求&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;500 Internal Server Error&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;503 Server Unavailable&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;消息报头：（见下）&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;消息主体：可选，返回的内容&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;消息报头&#34;&gt;消息报头&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;常见请求报文头信息&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Accept:text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8
Accept-Encoding:gzip, deflate, sdch, br
Accept-Language:en-US,en;q=0.8
Cache-Control:max-age=0
Connection:keep-alive
Cookie:BAIDUID=BDE50BA6209B0C5BC935D4BBF631F90D:FG=1; pgv_pvi=5348235264
Host:www.baidu.com
User-Agent:Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Ubuntu Chromium/58.0.3029.110 Chrome/58.0.3029.110 Safari/537.36
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;常见响应头信息&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Cache-Control:private
Connection:keep-alive
Content-Encoding:gzip
Content-Type:text/html; charset=utf-8
Date:Fri, 09 Jun 2017 09:08:42 GMT
Expires:Fri, 09 Jun 2017 09:08:42 GMT
Server:bfe/1.0.8.18
Set-Cookie:BDSVRTM=9; path=/
Set-Cookie:BD_HOME=0; path=/
Set-Cookie:H_PS_PSSID=1461_21094_17001_20929; path=/; domain=.baidu.com
Set-Cookie:__bsi=12742868508732542774_00_0_I_R_15_0303_C02F_N_I_I_0; expires=Fri, 09-Jun-17 09:08:47 GMT; domain=www.baidu.com; path=/
Strict-Transport-Security:max-age=172800
Transfer-Encoding:chunked
Vary:Accept-Encoding
X-Powered-By:HPHP
X-UA-Compatible:IE=Edge,chrome=1
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;浏览器打开网页完整过程&#34;&gt;浏览器打开网页完整过程&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;浏览器解析用户输入的URL&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;如果是输入的域名，则需要向DNS请求实际IP地址&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;DNS有缓存&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;DNS服务器如果本身没有数据，有一个向上级DNS服务器请求的过程&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;DNS解析一般会根据请求所在地区、网络（电信、联通）进行初步的负载均衡，返回一个相对较快的IP&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;拿到的IP地址，一般是一个前端服务器地址，前端服务器负责负载均衡，会为你分配一台服务器处理你的请求&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;负载均衡一般由LVS (Linux Virtual Server)，或者自定义服务实现&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;服务器会解析你的请求，处理请求，生成数据，渲染页面，返回页面&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;一般使用MVC框架&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;处理请求的过程一般不会是单台服务器能完成的，这里涉及到分布式集群、服务中间件、缓存、数据库、消息队列、日志等概念&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;请求一般分为搜索、事务&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;搜索：底层有一个分布式数据库建索引库的问题，上层有一个中文分词的问题&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;事务：购买、支付等都是事务，要保证事务在分布式环境中的完整性&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;用户访问的全部信息，可以被保存，用于数据挖掘&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;返回的页面，如果是一个重定向，浏览器会请求新的地址&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;返回的页面，如果包含资源/异步请求，浏览器会依次请求这些资源&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;返回的报文头，一般包含SessionID（一般放在Cookies里）。浏览器后继请求，会带上SessionID，用于服务器维持会话&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;会话可能会影响请求被分配处理的集群，比如，前后放在同一个机房处理，这个完全看服务端实现&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;请求的静态资源，一般会使用CDN (Content Delivery Network)，减轻主/计算服务器压力&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;如同分布式数据库，CDN有分发和同步的过程&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;浏览器拿到返回的页面（及页面内资源）后，有一个渲染的过程&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>TCP/IP协议摘要</title>
      <link>https://feng1st.github.io/post/2017-06-08-tcp-ip-protocol/</link>
      <pubDate>Thu, 08 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>https://feng1st.github.io/post/2017-06-08-tcp-ip-protocol/</guid>
      <description>

&lt;h2 id=&#34;协议分层&#34;&gt;协议分层&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;应用层 Application&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;对应OSI协议Application、Presentation、Session三层&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;常见上层协议：HTTP、FTP、SMTP、TELNET&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;传输层 Transport&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;对应OSI协议Transport层&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;协议：&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;TCP：（见下）&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;UDP：不超时重传、不错误重传、不保证顺序&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;网络层 Internet&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;对应OSI协议Network层&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;协议：&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;IP：（见下）&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;ARP：IP地址到MAC地址转换&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;DARP：（略）&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;ICMP：发生错误时，错误信息封包传给主机；IP重定向报文；路由发现报文&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;ping&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;traceroute&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;利用IP协议的TTL实现&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;利用主机不可达和端口不可达区分&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;网络接口层 Network Interface&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;对应OSI协议Data Link、Physical两层&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;附加以太网部首&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;ip协议&#34;&gt;IP协议&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;附加IP部首&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;TTL，生存周期，每路由一层减1，为0时丢弃&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;实现traceroute&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;路由顺序：&lt;br /&gt;

&lt;ol&gt;
&lt;li&gt;TTL为0时丢弃&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;匹配主机&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;匹配同子网路由器&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;匹配同网号路由器&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;匹配默认路由器&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;不保证可达，需配合ICMP由上层实现可靠性&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;tcp协议&#34;&gt;TCP协议&lt;/h2&gt;

&lt;p&gt;流量控制的思想可以用于上层应用的开发&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;附加TCP部首&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;可靠协议&lt;br /&gt;

&lt;ol&gt;
&lt;li&gt;合理分块&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;超时重发&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;校验和校验&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;发送确认&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;组装时排序&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;滑动窗口流控&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;建立连接，三次握手：&lt;br /&gt;
&lt;div class=&#34;mermaid&#34;&gt;
sequenceDiagram
    Client-&gt;&gt;Server: SYN
    Server--&gt;&gt;Client: ACK
    Client--&gt;&gt;Server: ACK
    
&lt;/div&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;断开连接，四次握手：&lt;br /&gt;
&lt;div class=&#34;mermaid&#34;&gt;
sequenceDiagram
    Client-&gt;&gt;Server: FIN
    Server--&gt;&gt;Client: ACK
    Server-&gt;&gt;Client: FIN
    Client--&gt;&gt;Server: ACK
    
&lt;/div&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;流量控制&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;延迟发送&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;捎带ACK：延迟发送ACK&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Nagle算法：延迟发送数据&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;滑动窗口 rwnd：接收方缓冲区&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;拥塞窗口 cwnd：探测带宽上限&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;慢启动阶段（未超过门限 ssthresh）&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;cwnd *= 2&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;拥塞避免阶段（超过门限）&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;cwnd += 1&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;超时重传&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;超时时间调整：简单的说，是一个涉及旧超时时间、新传输时间、经验系数、方差的函数&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;拥塞：某报文超时需要重传&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ssthresh /= 2&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cwnd = 1&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;进入慢启动阶段&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;快速重传：当收到3个重复ACK时（&lt;3个，乱序是大概率事件；&gt;=3个，丢包是大概率事件）&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ssthresh /= 2&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cwnd = ssthresh&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;进入拥塞避免阶段&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;快速恢复：（略）&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;其它计时器&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;坚持定时器：双方滑动窗口为0时的试探间隔，避免互相等待死锁&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;保活定时器：判断保持或断开半开放连接&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;2MSL定时器：端口可再次使用的计时器，在此期间，服务端可以重启而不报端口占用错误，但不可以建立连接&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Java内存模型和GC机制摘要</title>
      <link>https://feng1st.github.io/post/2017-06-07-jvm-memory-gc/</link>
      <pubDate>Wed, 07 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>https://feng1st.github.io/post/2017-06-07-jvm-memory-gc/</guid>
      <description>

&lt;h2 id=&#34;java对象&#34;&gt;Java对象&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;对象位置&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;对象实例在堆中分配&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;实例对应的类信息在方法区分配&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;对象信息&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;对象实例包含对象头和对象属性&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;对象头包含对象信息，包括分代年龄、锁信息等；还包括对方法区类信息的引用&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;类信息包含对父类/接口的引用，用于方法重载&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;对象大小&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;空对象大小等于对象头大小，在32位虚拟机占8字节，64位占16字节，开启压缩占12字节&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;引用在32位虚拟机占4字节，64位占8字节，开启压缩占4字节&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;数组类型大小要在元素类型大小上增加4字节数组长度&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;对象最终大小按8字节对齐&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;java内存区域&#34;&gt;Java内存区域&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;程序计数器 Program Counter Register&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;每线程&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;对于Java方法，记录当前字节码位置；对于Native方法，记录为Undefined&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;虚拟机栈 VM Stack&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;每线程&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;保存方法调用时的栈帧 Stack Frame&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;栈帧存放方法调用的局部变量表、操作栈、动态连接、方法出口等&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;局部变量表保存简单变量和对象的引用&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;栈帧大小在方法生存期内固定&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;如果栈深度超过虚拟机规定大小，抛出StackOverflowError&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;如果可供分配的内存不够，抛出OutOfMemoryError&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;本地方法栈 Native Method Stack&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;类似虚拟机栈&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;堆 Heap&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;线程共享&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;存储对象实例&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;是涉及GC的主要区域&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;方法区 Method Area&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;线程共享&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;保存加载的类信息（包括版本、接口、属性、方法、final常量、静态变量等）和运行时常量池 Runtime Constant Pool（包括字面常量、符号引用和直接引用）&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;在分代GC机制里，一般被成为永久代 Permanent Gen&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;对于存在大量Proxy动态类的系统，要考虑回收的问题&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;堆和栈的区别&#34;&gt;堆和栈的区别&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;栈：存放栈帧，内部包括简单变量和对象引用，在栈顶分配，后进先出，速度快&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;堆：存放对象实例，会因回收造成内存碎片，需要寻找下一个可供分配的连续空间，速度慢&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;对象访问方式&#34;&gt;对象访问方式&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;通过句柄池&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;栈或堆中的对象引用指向句柄池句柄，句柄分别指向堆中对象实例和方法区类信息&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;对象引用到句柄是多对一，句柄到对象实例是一对一，意味着对象实例因为GC移动而发生地址改变，只需要修改句柄&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;直接分配&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;栈或堆中的对象引用指向堆中的对象实例，对象实例内部指向方法区类信息&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;无中间层，较快。但是一旦对象实例移动，则需要更新所有的引用&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;HotSpot采用&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;对象生命周期&#34;&gt;对象生命周期&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;引用计数法&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;存在环状引用的问题&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;可达性分析算法&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;GC Roots&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;虚拟机栈引用的对象&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;本地方法栈引用的对象&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;方法区类静态属性引用的对象&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;方法区常量引用的对象&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;内存分代&#34;&gt;内存分代&lt;/h2&gt;

&lt;p&gt;不同对象的生存周期不同，不能因为回收短期对象，就扫描整个堆区&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;年轻代 Young Gen&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;默认分配区域&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;老年代 Old Gen&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;存放多次回收后依然幸存的对象，或者无法在年轻代分配的大对象&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;永久代 Permanent Gen&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;存放方法区内容，HotSpot采用，但计划弃用&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;回收算法&#34;&gt;回收算法&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;复制算法 Copying&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;A、B两块空间，在A块连续分配，空间不够时，将A块的存活对象依次复制到B块头部，并切换使用B块，A块清空&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;分配简单，连续分配，快；需要两倍空间，浪费；复制内容如果过大，依然会慢&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;标记-清除算法 Mark-Sweep&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;先对所有可回收对象做标记，然后再回收这些对象所占的空间&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;不需要移动，快；回收后会有内存碎片&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;标记-整理算法 Mark-Compact&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;先对所有可回收对象做标记，然后将幸存对象依次前移&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;需要移动，慢；回收后无内存碎片&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;分配机制&#34;&gt;分配机制&lt;/h2&gt;

&lt;p&gt;HotSpot中，年轻代分为1个Eden和2个Survivor。在Eden区分配对象，如果空间不足，将Eden区和活动Survivor区幸存对象，根据幸存次数，分别移至备用Survivor和老年代中，然后切换活动/备用Survivor。&lt;/p&gt;

&lt;h2 id=&#34;回收方式&#34;&gt;回收方式&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;串行 Serial&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;暂停用户线程，单线程回收&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;并行 Parallel&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;暂停用户线程，多线程并行回收&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;并发 Concurrent&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;回收线程和用户线程同时工作&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;垃圾回收器&#34;&gt;垃圾回收器&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Serial收集器&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;新生代&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;停止复制算法（停止 Stop-the-World，在垃圾回收时，暂停用户线程）&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;串行回收&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;ParNew收集器&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;新生代&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;停止复制算法&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;并行回收&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Parallel Scavenge收集器&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;新生代&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;停止复制算法&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;并行回收&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;关注吞吐量、支持自适应调节&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Serial Old收集器&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;老年代&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;停止标记整理算法&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;串行回收&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;CMS收集器Concurrent Mode Failure的后备&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Parallel Old收集器&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;老年代&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;停止标记整理算法&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;并行回收&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;搭配Parallel Scavenge收集器&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;CMS收集器&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;老年代&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;标记清除算法&lt;br /&gt;

&lt;ol&gt;
&lt;li&gt;初始标记：停止，串行，仅标记GC Roots直接引用的对象&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;并发标记：并发，从初始标记对象往下追踪&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;重新标记：停止，并行，修正并发标记期间改变的对象&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;并发清除：并发&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;并发回收会占用运行时CPU资源&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;因为是并发回收，所以要为GC期间新生成的对象预留空间，如果空间不够，会抛出Concurrent Mode Failure，回退到Serial Old收集器&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;因为是标记清除算法，如果产生的内存碎片导致可用连续空间不足，会触发一次带整理的Full GC&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;G1收集器&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;堆划分为相同的区域 Region&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;优先回收价值最大的区域&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;使用Remembered Set避免全堆扫描&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;整体为标记整理算法，区域间为复制算法&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;初始标记：停止，串行&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;并发标记：并发&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;最终标记：停止，并行&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;筛选回收：停止，并行&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;gc监控&#34;&gt;GC监控&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;jstat可以用来实时查看内存分配及GC信息&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;jmap可以dump出内存对象，供进一步分析&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Java命令行参数可以设置输出详细GC日志，供进一步分析&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>