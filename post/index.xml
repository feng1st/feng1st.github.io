<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on 技术随笔</title>
    <link>https://feng1st.github.io/post/</link>
    <description>Recent content in Posts on 技术随笔</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Mon, 14 Aug 2017 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://feng1st.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Spring Cloud Config</title>
      <link>https://feng1st.github.io/post/2017/08/spring-cloud-config-docs/</link>
      <pubDate>Mon, 14 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://feng1st.github.io/post/2017/08/spring-cloud-config-docs/</guid>
      <description>原文（英文）
翻译：Feng
Spring Cloud Config在分布式系统里为使用外部配置提供了服务端和客户端支持。使用Config Server，你可以在一个地方，为跨环境的各种应用集中管理外部参数。不管是在客户端还是服务端，这个概念和Spring Environment、PropertySource抽象都是等价的，所以它们可以被Spring应用无缝使用，但不妨碍它们被任何语言任何应用使用。当一个应用在部署管道（deployment pipeline）里，从dev环境迁移到test再到production时，你可以管理在这些环境上的配置并确保应用能拿到它所需的一切参数。服务端存储后台默认实现为git，所以配置天然支持标签和版本，并且有大量的工具可用于内容的管理。你也可以很容易利用Spring配置添加和插入其它实现。
快速开始 启动服务端：
$ cd spring-cloud-config-server $ ../mvnw spring-boot:run  服务端是一个Spring Boot应用，所以你也可以从IDE里面直接启动（main类是ConfigServerApplication）。然后试运行客户端：
$ curl localhost:8888/foo/development {&amp;quot;name&amp;quot;:&amp;quot;development&amp;quot;,&amp;quot;label&amp;quot;:&amp;quot;master&amp;quot;,&amp;quot;propertySources&amp;quot;:[ {&amp;quot;name&amp;quot;:&amp;quot;https://github.com/scratches/config-repo/foo-development.properties&amp;quot;,&amp;quot;source&amp;quot;:{&amp;quot;bar&amp;quot;:&amp;quot;spam&amp;quot;}}, {&amp;quot;name&amp;quot;:&amp;quot;https://github.com/scratches/config-repo/foo.properties&amp;quot;,&amp;quot;source&amp;quot;:{&amp;quot;foo&amp;quot;:&amp;quot;bar&amp;quot;}} ]}  定位属性源（property source）的默认策略是克隆一个git仓库（在spring.cloud.config.server.git.uri）然后用它来初始化一个迷你SpringApplication。这个迷你应用的Environment被用来枚举属性源并通过一个JSON端点（endpoint）发布它们。
这个HTTP服务有这些形式的资源：
/{application}/{profile}[/{label}] /{application}-{profile}.yml /{label}/{application}-{profile}.yml /{application}-{profile}.properties /{label}/{application}-{profile}.properties  这里，&amp;rdquo;application&amp;rdquo;以spring.config.name被注入SpringApplication（即标准Spring Boot应用），&amp;rdquo;profile&amp;rdquo;是一个活动配置文件（或者逗号分隔的属性列表），&amp;rdquo;label&amp;rdquo;是一个可选的git标签（默认为&amp;rdquo;master&amp;rdquo;）。
Spring Cloud Config服务端从一个git仓库（必须提供）为远程客户端拉取配置：
spring: cloud: config: server: git: uri: https://github.com/spring-cloud-samples/config-repo  客户端用法 要在应用中使用这些功能，你只需要创建一个依赖spring-cloud-config-client的Spring Boot应用（参见config-client的测试案例，或者sample app）。添加依赖最方便的方式是通过Spring Boot starter org.springframework.cloud:spring-cloud-starter-config。对Maven用户，这里有一个父pom和BOM（spring-cloud-starter-parent）；对Gradle和Spring CLI用户，这里也有一个Spring IO版本管理属性文件。示例Maven配置：
pom.xml
&amp;lt;parent&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.3.5.RELEASE&amp;lt;/version&amp;gt; &amp;lt;relativePath /&amp;gt; &amp;lt;!-- lookup parent from repository --&amp;gt; &amp;lt;/parent&amp;gt; &amp;lt;dependencyManagement&amp;gt; &amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.</description>
    </item>
    
    <item>
      <title>Docker容器运行dubbo应用</title>
      <link>https://feng1st.github.io/post/2017/06/dubbo-in-docker/</link>
      <pubDate>Tue, 27 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>https://feng1st.github.io/post/2017/06/dubbo-in-docker/</guid>
      <description>参考了这篇文章： https://yq.aliyun.com/articles/60789
大致步骤是一样的。但是，文章中的部署方式是，使用docker-compose，将zookeeper、provider、consumer编排在一起了。
它们使用的是同一个虚拟网络，provider将自己在虚拟网络里的ip注册到zookeeper，consumer能顺利访问到。
但开发环境一般会分开部署，zookeeper、provider、consumer一般不在同一个网络。
为了让consumer能够通过provider注册到zookeeper里的ip进行访问，这里让provider直接使用host的网络，多个provider靠端口区分。
application.properties
server.port=${SERVER_PORT:0}  这个是用来区分spring-boot-starter-web里自带tomcat的端口
services.xml
 &amp;lt;dubbo:registry protocol=&amp;quot;zookeeper&amp;quot; address=&amp;quot;${ZOO_SERVERS}&amp;quot;/&amp;gt; &amp;lt;dubbo:protocol name=&amp;quot;dubbo&amp;quot; port=&amp;quot;${DUBBO_PORT}&amp;quot;/&amp;gt;  这个是用来区分provider通过dubbo协议暴露服务的端口
docker-compose.yml
version: &#39;2&#39; services: provider1: image: provider restart: always network_mode: host environment: ZOO_SERVERS: localhost:2181,localhost:2182,localhost:2183 DUBBO_PORT: 20880 SERVER_PORT: 8080 provider2: image: provider restart: always network_mode: host environment: ZOO_SERVERS: localhost:2181,localhost:2182,localhost:2183 DUBBO_PORT: 20881 SERVER_PORT: 8081  起了两个实例，分别占用主机网络的20880, 8080, 20881, 8081端口
zookeeper集群使用自己的网络，但是将端口映射到了主机的2181, 2182, 2183
更复杂的部署，应考虑使用Docker Swarm
还有其它一些细节，可以参考源代码：
https://github.com/feng1st/microservices-demo</description>
    </item>
    
    <item>
      <title>Spring实现RESTful Service笔记</title>
      <link>https://feng1st.github.io/post/2017/06/spring-rest/</link>
      <pubDate>Mon, 26 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>https://feng1st.github.io/post/2017/06/spring-rest/</guid>
      <description>来源：
https://spring.io/guides/gs/rest-service/
本文采用代码及分析的形式
GreetingController.java src/main/java/hello/GreetingController.java
package hello; import java.util.concurrent.atomic.AtomicLong; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestParam; import org.springframework.web.bind.annotation.RestController; @RestController public class GreetingController { private static final String template = &amp;quot;Hello, %s!&amp;quot;; private final AtomicLong counter = new AtomicLong(); @RequestMapping(&amp;quot;/greeting&amp;quot;) public Greeting greeting(@RequestParam(value=&amp;quot;name&amp;quot;, defaultValue=&amp;quot;World&amp;quot;) String name) { return new Greeting(counter.incrementAndGet(), String.format(template, name)); } }   @RestController
 整合@Controller, @ResponseBody
 @Controller
 MVC里的Controller，Spring的DispatcherServlet，通过HandlerMapping，找到Controller后，将请求发送过来进行处理
  @ResponseBody
 将返回的对象，通过注册的HttpMessageConverter，转换成字符串，写入Response的body里
 对应的是@RequestBody，通过Request header的Content-Type，将Request的body转换成对象
   @RequestMapping</description>
    </item>
    
    <item>
      <title>Spring DispatcherServlet相关知识点</title>
      <link>https://feng1st.github.io/post/2017/06/spring-dispatcher-servlet/</link>
      <pubDate>Sun, 25 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>https://feng1st.github.io/post/2017/06/spring-dispatcher-servlet/</guid>
      <description>DispatcherServlet作用  作为Spring MVC的集中访问点
 通过HandlerMapping，将请求映射到Handler
 返回一个HandlerExecutionChain，包含一个HandlerAdaptor和多个HandlerInterceptor
  通过不同的HandlerAdaptor，支持不同的处理器
 通过ViewResolver，支持到具体视图的解析
 通过HandlerExceptionResolver，实现对异常的处理
  每一部分都可以很方便的扩展
DispatcherServlet流程  请求被DispatcherServlet截获
 DispatcherServlet在候选handlerMappings里面，找到第一个能够处理request的handlerMapping
 常见的handlerMapping：
 RequestMappingHandlerMapping: 通过@RequestMapping注解的Controller的方法
 内部有一个url到HandlerMethod的映射，通过这个映射来判断是否能处理
  BeanNameUrlHandlerMapping: 通过web.xml配置的，从URL映射到bean。DispatcherServlet本身就是通过这种方式配置
   handlerMapping构造一个HandlerExecutionChain
 HandlerExecutionChain包含多个HandlerInterceptor和一个Handler
 Handler是一个HandlerMethod，通过构造函数参数传入request
 Spring MVC默认会注入一个ConversionServiceExposingInterceptor，用来处理日期、时间等格式转换
   用HandlerAdaptor封装chain里的handler
 不同的handler接口不同，通过adaptor统一接口
 DispatcherServlet有一个HandlerAdaptor的列表，采用第一个.supports(handler)的HandlerAdaptor
 HandlerMethod对应的是RequestMappingHandlerAdaptor
  依次执行各interceptor的preHandle，handlerAdaptor的handle和各interceptor的postHandle
 HandlerAdaptor内部实例化一个ServletInvocableHandlerMethod
 除了handler，还注入了HandlerMethodArgumentResolver列表、HandlerMethodReturnValueHandler列表以及DataBinderFactory
  ServletInvocableHandlerMethod.invokeAndHandle()里
 用argumentResolvers和dataBinderFactory转化参数
 用argumentResolvers解析参数</description>
    </item>
    
    <item>
      <title>微服务架构摘要</title>
      <link>https://feng1st.github.io/post/2017/06/microservices/</link>
      <pubDate>Fri, 23 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>https://feng1st.github.io/post/2017/06/microservices/</guid>
      <description>原文: https://www.nginx.com/blog/introduction-to-microservices/
单一框架有什么问题 / 微服务框架解决什么问题？ 单一框架经过常年发展，扩充之后：
 过于复杂，难于理解和修改。修改容易引入bug
 启动变慢，降低调试和开发速度
 无法持续部署，无法快速升级。一个组件需要升级，整个应用都需要重新部署。部署后，因为受影响部分不明，需要更多的人工测试
 无法根据不同组件的需求进行伸缩扩展。比如，部分组件是CPU密集型，部分组件是内存密集型；部分组件压力小，单个实例可以应付，部分组件压力大，有部署多个实例的需求
 可靠性，组件异常（比如内存泄露），导致整个应用异常
 难于升级到新的技术和框架
  微服务框架  按功能划分，比如订单管理、客户端管理
 每个微服务是一个单独的小应用
 微服务对外暴露API，比如REST API
微服务之间可以通过暴露的API互相调用
微服务间还可以通过消息系统实现异步调用
外界一般不直接范围后端服务，而是通过API网关
 微服务通常通过虚拟机或Docker部署
  伸缩模型 x轴：水平复制，靠克隆伸缩。通过在负载均衡后部署多个实例，解决可用性和吞吐量的问题
y轴：功能解耦，靠拆分不同的事物伸缩。将单一应用通过功能/业务拆分成多个微服务
z轴：数据分区，靠拆分相似的事物伸缩
微服务架构对数据库schema的影响 微服务架构要求每个微服务有自己单独的数据库schema
这是为了更彻底的解耦
但是不可避免的，多个微服务数据库间存在重复数据
微服务架构和SOA的异同 微服务架构和SOA在表现层有相似性：都是由多个服务构成
区别：
1. 微服务架构弃用了比较重的WS规范，采用轻量的协议，比如REST
2. 微服务架构弃用了ESB
微服务的好处  将单一应用解构成多个服务，让每一个服务面临的复杂度降低，变得可管理、可控制、可维护
 开发方面：可以选用自己的技术，可以使用较新的技术
 部署方面：可以单独部署，更容易部署和测试
 伸缩方面：更容易按需扩展多实例
  微服务的问题 下面这些问题都不难解决，但是需要清楚存在这些问题
 分布式架构下调用的开销，以及服务不可用的处理
 数据库拆分后，分布式事务基本不采用，需要最终一致方案
 测试更困难，可能需要启动服务本身和依赖服务（或者伪服务）</description>
    </item>
    
    <item>
      <title>工具推荐：PlantUML，文本转UML图工具</title>
      <link>https://feng1st.github.io/post/2017/06/plantuml/</link>
      <pubDate>Thu, 22 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>https://feng1st.github.io/post/2017/06/plantuml/</guid>
      <description>官网：http://plantuml.com/
为什么要用文本生成UML，而不直接画UML？
这就好像问为什么要用markdown，而不直接使用.odt或者.docx格式。答案一样：
这属于强迫症，得治。
安装 如果使用ubuntu，直接：
sudo apt-get install graphviz plantuml
其它平台或者安装方法请参考官网
使用 plantuml src.txt
如果是下载的jar：
java -jar plantuml.jar src.txt
会在当前目录下生成src.png
示例 输入：
jetty-handler.pu
@startuml interface Handler { +handle(request) } abstract class AbstractHandler class HandlerWrapper class ServletHandler class HandlerContainer class Server class SessionHandler { +SessionManager } class SecurityHandler { +SecurityConstraint[] } class ContextHandler { +contextPath +resourceBase +classLoader } class ContextHandlerContainer { -contexts: PathMap } class WebAppContext { +descriptor } Handler &amp;lt;|.</description>
    </item>
    
    <item>
      <title>面向服务架构笔记</title>
      <link>https://feng1st.github.io/post/2017/06/soa/</link>
      <pubDate>Sun, 18 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>https://feng1st.github.io/post/2017/06/soa/</guid>
      <description>分布式应用架构的演化  DOA 分布式对象架构
 主要特征：
 对象是可以在服务器/容器间自由“移动”的
 被调用的对象究竟是本地，还是远程，对调用者来说是透明的
  例子：EJB
 问题：复杂和性能
 远程调用有更多可能出错的环节
 分布式事务需要两阶段提交
 远程通讯额外的开销
   SOA 面向服务架构
 服务是可“移动”的，但是远没有DOA那样不可控
 当调用其它服务时，调用者知道这是一个远程调用。对复杂度和性能有更好的把控
   企业服务总线 ESB ESB是SOA的核心组件，其主要特点：
 服务访问单点：服务提供者和服务消费者都只需要知道ESB的存在。服务发生变化，只需要修改ESB的配置
 事物管理器：分布式事物管理器放在这个地方很自然
 安全管理器：访问权限、授权管理
 服务代理：统一服务接口和数据格式的一个Adaptor和Proxy
 对外部的网关
  但是ESB也有一定的缺点：
 单点故障：ESB发生故障，整个系统将不可用
 单点性能：分布式系统中，承担ESB角色的单点是必须的，比如服务注册和发现。
但是，究竟要承担哪些具体的工作，是一个需要考虑的点。
比如，如果服务之间的通讯都要经过ESB，ESB会不会成为整个系统的性能瓶颈，会不会增大故障的概率
 同上，增加了服务间访问的间接性，降低了性能
  SOA简介 SOA的目标是实现灵活可变的分布式IT系统，这需要：
 标准化：协议标准化，实现互访问
 复用：服务可复用
 松耦合可编排：分布式对象技术分离了连接逻辑，消息中间件实现了连接逻辑的异步，SOA架构实现了业务逻辑的解耦
  SOA治理  服务注册与发现</description>
    </item>
    
    <item>
      <title>高并发解决思路</title>
      <link>https://feng1st.github.io/post/2017/06/high-concurrency/</link>
      <pubDate>Sat, 17 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>https://feng1st.github.io/post/2017/06/high-concurrency/</guid>
      <description>解决高并发，无非两个方向：
 分而治之：分流
 优化单个服务器处理能力
  客户端  尽量使用缓存
 尽量本地处理
 尽量减少不必要的访问
  分流 LVS、Nginx、Varnish放到一块说
 负载均衡
 业务拆分
 静态内容直接返回，包括使用CDN
 缓存（动态内容缓存、页面片段缓存）
  优化单个服务器处理程序  缓存：缓存永远是最重要的
 异步：能异步就异步
如果有多个异步调用没有依赖关系，可以并行调用，然后在最后一起等结果
 多线程：
如果是CPU吃重的应用，线程数过高不能解决问题
I/O吃重要分成两种：1种是因为传输数据量过大，导致I/O重，这种线程数高不解决问题
另一种是传输数据不大，但是等待远端处理的时间很长，这种可以提升线程数，并发处理后面的任务
 预处理：预先算出局部结果，要获取整体结果时，只需要基于局部结果计算。比如月报表可以基于天报表
 还有一种预处理，是和缓存结合的预处理
不是等到缓存失效时，再穿透后端。而是缓存快要失效时，就起线程向后端请求数据更新缓存。在线程处理期间，缓存里的数据依然是有效的。线程处理完毕，缓存里的数据已更新
 优化SQL，正确使用索引
 尽量不要使用分布式事务
2阶段提交不是万能药
 各节点进入事务
 各节点事务执行完毕，prepare（意味着，接下来出了问题，比如重启，事务也能生效）
 各节点commit
假设最后一个节点，commit前离线了，并且永远不再上线，事务状态依然是错误的
  应用算法优化
  优化数据层  合理选用数据库（OLTP、OLAP）和引擎（InnoDB、MyISAM）
 合理设置索引
 使用集群，读写分离
 合理分表分库</description>
    </item>
    
    <item>
      <title>Tomcat笔记</title>
      <link>https://feng1st.github.io/post/2017/06/tomcat/</link>
      <pubDate>Wed, 14 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>https://feng1st.github.io/post/2017/06/tomcat/</guid>
      <description>架构  Server: 整个容器
 Service: 关联Container和Connector的中间人，包含一个Container和多个Connector
 Connector: 负责和客户端的网络通讯，接受/建立连接，接收请求，返回响应
 维持一个一定大小的线程池，创建多个Processor，当请求来的时候，将socket和processor绑定，然后运行
 Request, Response是在这里创建的，然后传递给Container
 低版本Tomcat可以修改配置文件server.xml，为Connector使用protocol=&amp;quot;org.apache.coyote.http11.Http11NioProtocol&amp;quot;
  Container: 所有容器的父接口，下面4个重要的实现类/子接口
 Engine, Host, Context, Wrapper
 4个之间不是并列关系，是父子包含关系
  Engine: 是一个Service的根容器，处理请求的总管道 Pipeline
 Host: Engine的子容器，负责处理访问某特定host的请求。还实现了Deployer接口，实现应用程序的展开、部署、启动
 Context: Host的子容器，负责处理访问某特定路径 path 的请求。也是我们的单个应用程序的单位
 Wrapper: Context的子容器，负责调用Filter和Servlet
 LifeCycle: 生命周期管理，包括父容器启动时，分别启动子容器。父容器结束前，分别结束子容器
 Pipeline: Valve的容器，请求传递的责任链。Pipeline内的Valve依次调用，最后一个Valve调用下一层级的Pipeline
 EngineValve1 -&amp;gt; EngineValve2 -&amp;gt; ... -&amp;gt; StandardEngineValve -&amp;gt; HostPipeline
  Valve: Pipeline的切入点
 StandardEngineValve: Engine pipeline上最后一个valve，调用Host
 StandardHostValve: Host pipeline上最后一个valve，调用Context</description>
    </item>
    
    <item>
      <title>Jetty笔记</title>
      <link>https://feng1st.github.io/post/2017/06/jetty/</link>
      <pubDate>Mon, 12 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>https://feng1st.github.io/post/2017/06/jetty/</guid>
      <description>核心组成部分  Server
 Connector
 Handler
 ThreadPool
 LifeCycle
  LifeCycle start(); stop();   管理server对象的生命周期
 Connector, Handler, ThreadPool都实现了LifeCycle接口
 LifeCycle的监听使用了观察者模式
  Connector  接受TCP连接
 用配置的ConnectionFactory创建Connection，和连接绑定
 可配置多个ConnectionFactory，链式调用，分别完成各自一层的工作，比如：
 ProxyConnectionFactory：处理Proxy协议
 SslConnectionFactory：SSL加密解密
 HttpConnectionFactory：处理实际的HTTP请求
   Handler  Jetty用一个Handler模型就完成了请求在整个server的不同层级的处理，这个是Jetty保持轻量和容易扩展的原因，这里说一下它的设计模式。
 HandlerWrapper：形式上是装饰者模式，使用方式上是责任链模式
 装饰者模式 Decorator：实现对所包装对象在本层级的拦截。比如，SessionHandler处理Session，SecurityHandler处理安全验证后，再调用被包装Handler的handle()
 责任链模式 Chain of Responsibility：已经提到过，调用被包装Handler的handle()，实现责任链
  HandlerContainer：组合模式 Composite，树形结构
 模板方法 Template Method：比如ScopedHandler.doScope()，更清晰的向使用者阐述类的职责
 门面模式 Facade：Context相关类，限制暴露方法的范围
  Handler风格分类：</description>
    </item>
    
    <item>
      <title>Servlet笔记</title>
      <link>https://feng1st.github.io/post/2017/06/servlet/</link>
      <pubDate>Sun, 11 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>https://feng1st.github.io/post/2017/06/servlet/</guid>
      <description>教程：
http://tutorials.jenkov.com/java-servlets/
一些思考点  Servlet的生命周期是怎样被容器管理的？
 Session是怎样被管理和传递的？
 分布式环境下Session是怎样被管理的？
 统一Session中心
 或者Session Sticky
  ServletContext是怎样被管理和传递的，典型用途是什么？
 request.getSession().getServletContext();
  为什么要使用RequestDispatcher，而不是，比如直接调用其它Servlet？
 Filter和Servlet有什么异同？
 接口
 Servlet: init(), service(), destroy()
 HttpServlet: doGet(), doPost(), &amp;hellip;
  Filter: init(), doFilter(), destroy()
  设计
 Servlet: 面向事务
 Filter: 面向切面
   Filter和Servlet分属不同两个类，为什么filterChain.doFilter()能把请求传递给Servlet
 filterChain最后一个默认的filter调用servlet
  怎样用Filter实现GZip，这个实现和AOP有什么区别？
 判断请求头Accept-Encoding是否包括gzip
 增加响应头Content-Encoding
 用带GZip的Response封装原Response，并向后传递
  Session和ServletContext是线程安全的吗？</description>
    </item>
    
    <item>
      <title>Java NIO摘要</title>
      <link>https://feng1st.github.io/post/2017/06/java-nio/</link>
      <pubDate>Sat, 10 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>https://feng1st.github.io/post/2017/06/java-nio/</guid>
      <description>比较经典和精简的教程，先直接发链接：
http://tutorials.jenkov.com/java-nio/
NIO的实现不复杂，但是其体现了一个统一、可伸缩的面向数据/信息流的设计思想
例如，换用消息队列，就可以扩展到分布式系统里去
一些思考点  Channel和Stream有什么不同？
 Channel双向，Stream一般单向
 Channel支持异步
 Channel搭配Buffer使用
  ServerSocketChannel和SocketChannel有什么不同？
 SocketChannel用于单个连接
 ServerSocketChannel用于监听端口，对每一个接受的连接创建一个SocketChannel
  FileChannel.transferTo(&amp;hellip;, SocketChannel)有什么需要注意的？
 SocketChannel非阻塞且发送缓冲已满，可能只传输部分
  SocketChannel的blocking和non-blocking模式有什么不同？
 相对于阻塞，connect()直接返回，需要后继调用finishConnect()判断成功
 write()/read()可能未实际读写就返回
  ServerSocketChannel的blocking和non-blocking模式有什么不同？
 相对于阻塞，accept()直接返回，如没有接受连接，返回null
 write()/read()可能未实际读写就返回
  Blocking模式Socket有什么问题？
 一般会用一个线程处理一个连接，所以支撑的连接数非常有限
 如果使用连接池复用活动连接，一些慢速或者非活动连接可能会占满连接池
  Non-blocking模式Socket有哪些挑战？
 读到的字节流拆分Message：文章提到了TLV，但最好用长度+内容+校验构成
 长度：TLV中的L
 内容：类型是包含在这里面的，比如protobuf协议
 校验：用于验证数据错误，或者网络错误，通知重传
  读写的Message要有长度限制，否则一个伪造的字节流就能把服务器撑垮
 一般会定义一种特定Message，专门用来拆分大的其它Message，长度和校验部分机制不变，内容部分构成如下
 总段数
 本段序号
 本段内容</description>
    </item>
    
    <item>
      <title>HTTP协议摘要</title>
      <link>https://feng1st.github.io/post/2017/06/http-protocol/</link>
      <pubDate>Fri, 09 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>https://feng1st.github.io/post/2017/06/http-protocol/</guid>
      <description>HTTP协议概述  基于服务器/客户端，请求/响应
 无连接（1.1开始支持长连接Web Socket）
 无状态（需要依赖会话维持状态）
 应用层协议，基于TCP
  URL http://host:port/res_uri.html?param=...
 协议：如http, https, ftp等
 用户名/密码：部分协议例如ftp支持用户名密码
 域名和端口：要访问服务器的域名和端口，不同协议有自己的默认端口
 访问资源：要访问资源的路径和参数
  请求 GET /index.html HTTP/1.0&amp;lt;CRLF&amp;gt; Host:www.sina.com.cn&amp;lt;CRLF&amp;gt; Accept-Encoding:gzip, deflate&amp;lt;CRLF&amp;gt; User-Agent:Mozilla/4.0(compatible;MSIE6.0;Windows NT 5.0)&amp;lt;CRLF&amp;gt; Connection:Keep-Alive&amp;lt;CRLF&amp;gt; &amp;lt;CRLF&amp;gt; {Optional Content Body}   起始行：Method Request-URI HTTP-Version
 请求方法
 GET 请求Request-URI所标识的资源
 POST 在资源后附加新的数据
 HEAD 请求获取资源的响应消息报头
 PUT 请求服务器存储一个资源
 DELETE 请求删除资源
 TRACE 请求服务器回送收到的请求信息，用于诊断测试
 CONNECT 保留字</description>
    </item>
    
    <item>
      <title>TCP/IP协议摘要</title>
      <link>https://feng1st.github.io/post/2017/06/tcp-ip-protocol/</link>
      <pubDate>Thu, 08 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>https://feng1st.github.io/post/2017/06/tcp-ip-protocol/</guid>
      <description>协议分层  应用层 Application
 对应OSI协议Application、Presentation、Session三层
 常见上层协议：HTTP、FTP、SMTP、TELNET
  传输层 Transport
 对应OSI协议Transport层
 协议：
 TCP：（见下）
 UDP：不超时重传、不错误重传、不保证顺序
   网络层 Internet
 对应OSI协议Network层
 协议：
 IP：（见下）
 ARP：IP地址到MAC地址转换
 DARP：（略）
 ICMP：发生错误时，错误信息封包传给主机；IP重定向报文；路由发现报文
 ping
 traceroute
 利用IP协议的TTL实现
 利用主机不可达和端口不可达区分
     网络接口层 Network Interface
 对应OSI协议Data Link、Physical两层
 附加以太网部首
   IP协议  附加IP部首
 TTL，生存周期，每路由一层减1，为0时丢弃
 实现traceroute
   路由顺序：</description>
    </item>
    
    <item>
      <title>Java内存模型和GC机制摘要</title>
      <link>https://feng1st.github.io/post/2017/06/jvm-memory-gc/</link>
      <pubDate>Wed, 07 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>https://feng1st.github.io/post/2017/06/jvm-memory-gc/</guid>
      <description>Java对象  对象位置
 对象实例在堆中分配
 实例对应的类信息在方法区分配
  对象信息
 对象实例包含对象头和对象属性
 对象头包含对象信息，包括分代年龄、锁信息等；还包括对方法区类信息的引用
 类信息包含对父类/接口的引用，用于方法重载
  对象大小
 空对象大小等于对象头大小，在32位虚拟机占8字节，64位占16字节，开启压缩占12字节
 引用在32位虚拟机占4字节，64位占8字节，开启压缩占4字节
 数组类型大小要在元素类型大小上增加4字节数组长度
 对象最终大小按8字节对齐
   Java内存区域  程序计数器 Program Counter Register
 每线程
 对于Java方法，记录当前字节码位置；对于Native方法，记录为Undefined
  虚拟机栈 VM Stack
 每线程
 保存方法调用时的栈帧 Stack Frame
 栈帧存放方法调用的局部变量表、操作栈、动态连接、方法出口等
 局部变量表保存简单变量和对象的引用
 栈帧大小在方法生存期内固定
  如果栈深度超过虚拟机规定大小，抛出StackOverflowError
 如果可供分配的内存不够，抛出OutOfMemoryError
  本地方法栈 Native Method Stack
 类似虚拟机栈</description>
    </item>
    
    <item>
      <title>大型网站系统与Java中间件实践 读书笔记</title>
      <link>https://feng1st.github.io/post/2017/05/large-website-system-and-java-middleware-practice/</link>
      <pubDate>Mon, 01 May 2017 00:00:00 +0000</pubDate>
      
      <guid>https://feng1st.github.io/post/2017/05/large-website-system-and-java-middleware-practice/</guid>
      <description>豆瓣链接: https://book.douban.com/subject/25867042/
作者曾宪杰，淘宝花名华黎，现任淘宝技术部总监。
本书反映了淘宝网一路发展过来，技术架构演进的一个过程。书中的绝大多数内容，都已经落地为阿里内部广泛使用的基础设施、中间件。部分组件已经开源，比如Dubbo、RocketMQ，可以在网上下到。
本文是读书过程中对部分重要知识点的一个记录，也可以当作回顾时的索引。
第1章 分布式系统介绍 1.2.3.2 网络IO实现方式  BIO/NIO/AIO
  1.2.4.3 控制器的变化  使用硬件/LVS负载均衡
 增加网络开销（流量，延迟）
 单点
  使用名称服务的直接连接方式
 服务提供方 &amp;ndash;注册&amp;ndash;&amp;gt; 名称服务 &amp;ndash;&amp;gt; 请求方 (负载均衡)
 代码升级比较复杂
  使用规则服务器
 规则服务器 &amp;ndash;规则&amp;ndash;&amp;gt; 请求方 (规则计算)
  Master+Worker
 Master (规则计算) &amp;ndash;结果&amp;ndash;&amp;gt; 请求方
   1.2.5 分布式系统的难点  缺乏全局时钟
 单独集群管理时序
  应对/解决故障独立性
 处理单点故障
 事务
  第2章 大型网站及其架构演进过程 2.</description>
    </item>
    
  </channel>
</rss>